<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨sirの客栈</title>
  
  <subtitle>杨sirの客栈</subtitle>
  <link href="http://121.43.167.55/atom.xml" rel="self"/>
  
  <link href="http://121.43.167.55/"/>
  <updated>2023-06-07T11:41:41.146Z</updated>
  <id>http://121.43.167.55/</id>
  
  <author>
    <name>杨sir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java复习：七大软件设计原则</title>
    <link href="http://121.43.167.55/2023/060750821.html"/>
    <id>http://121.43.167.55/2023/060750821.html</id>
    <published>2023-06-07T11:25:37.000Z</published>
    <updated>2023-06-07T11:41:41.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java复习：七大软件设计原则"><a href="#Java复习：七大软件设计原则" class="headerlink" title="Java复习：七大软件设计原则"></a>Java复习：七大软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据七条原则来开发程序，从而提高开发效率、节约软件成本。<br><img src="/../img/bg1/posts/%E8%84%91%E5%9B%BE.png" alt="在这里插入图片描述"></p><h2 id="一、开闭原则"><a href="#一、开闭原则" class="headerlink" title="一、开闭原则"></a>一、开闭原则</h2><p><strong>面向抽象编程，对扩展开放，对修改关闭。</strong></p><p>在程序需要进行拓展的时候，不能去修改原有的代码，而是实现一个热插拔的效果，提升程序的扩展性，易于维护和升级。</p><p>实现：采用接口和抽象类</p><p>说明：简单来说，抽象灵活性好，适用性广，只要抽象的合理，可以基本保持软件架构的稳定。当中的细节可以从抽象派生来的实现类进行扩展，当软件需要修改时只要根据需求重新派生一个实现类来扩展就可以了。</p><h2 id="二、里式代换原则"><a href="#二、里式代换原则" class="headerlink" title="二、里式代换原则"></a>二、里式代换原则</h2><p><strong>维护继承体系，子类在继承父类时不要修改父类的方法，不要影响父类方法的含义。</strong></p><p><strong>一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。</strong></p><p>子类可以扩展父类的功能，但不能改变父类原有的功能，也就是说，子类在继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><ul><li>约束继承泛滥，里氏替换原则是实现开闭原则的重要方式之一，是开闭原则的一种体现。</li><li>克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险</li></ul><p><img src="/../img/bg1/posts/%E9%87%8C%E5%BC%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%E6%8F%92%E5%9B%BE.png" alt="在这里插入图片描述"></p><h2 id="三、依赖倒转原则"><a href="#三、依赖倒转原则" class="headerlink" title="三、依赖倒转原则"></a>三、依赖倒转原则</h2><p><strong>依赖倒置原则（Dependence Inversion Principle，DIP）是指设计代码结构时，高层模块不应该依赖低层模块，二者都应该依赖其抽象。</strong></p><p><strong>面向接口编程，不要过分依赖实现类，降低耦合度，多关注接口与抽象。</strong></p><p>抽象不应该依赖细节，细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并且能够降低修改程序所造成的风险。</p><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><ul><li>有效控制影响范围</li><li>增强代码可读性和可维护性</li><li>降低耦合</li></ul><p><strong>以抽象为基准比以细节为基准搭建起来的架构要稳定得多</strong>，因此在拿到需求后，要面相接口编程，先顶层设计再细节地设计代码结构。</p><p><img src="/../img/bg1/posts/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99.png" alt="在这里插入图片描述"></p><h2 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h2><p><strong>一个接口只干一件事情，尽量精简单一，不要接口方法冗余。</strong></p><p>接口隔离原则（Interface Segregation Principle，简称ISP）是指客户不应该依赖它们用不到的方法，只给每个客户它所需要的接口。换句话说，就是不能强迫用户去依赖那些他们不使用的接口。</p><p>接口隔离原则实际上包含了两层意思：</p><ul><li>接口的设计原则：接口的设计应该遵循最小接口原则，不要把用户不使用的方法塞进同一个接口里。如果一个接口的方法没有被使用到，则说明该接口过胖，应该将其分割成几个功能专一的接口，使用多个专门的接口比使用单一的总接口要好。</li><li>接口的继承原则：如果一个接口A继承另一个接口B，则接口A相当于继承了接口B的方法，那么继承了接口B后的接口A也应该遵循上述原则：不应该包含用户不使用的方法。反之，则说明接口A被B给污染了，应该重新设计它们的关系。</li></ul><p>如果用户被迫依赖他们不使用的接口，当接口发生改变时，他们也不得不跟着改变。换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。</p><p><img src="/../img/bg1/posts/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%8F%92%E5%9B%BE.png" alt="在这里插入图片描述"></p><h2 id="五、迪米特法则"><a href="#五、迪米特法则" class="headerlink" title="五、迪米特法则"></a>五、迪米特法则</h2><p><strong>“最少知道法则”：关注于类本身，不该知道的不要知道；类与类之间相互独立，降低耦合度。</strong></p><p>迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——<strong>这在一定程度上增加了系统的复杂度</strong>。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><ul><li>1）当前对象本身（this）</li><li>2）以参数形式传入到当前对象方法中的对象.；方法入参是一个对象, 这是这个对象和当前类是朋友</li><li>3）当前对象的实例变量直接引用的对象；定一个一个类, 里面的属性引用了其他对象, 那么这个对象的实例和当前实例是朋友</li><li>4）当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友；如果属性是一个对象, 那么属性和对象里的元素都是朋友</li><li>5）当前对象所创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”。</p><p>缺点：在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的业务逻辑无关。遵循类之间的迪米特法则会是一个系统的局部设计简化，因为每一个局部都不会和远距离的对象有直接的关联。但是，这也会造成系统的不同模块之间的通信效率降低，也会使系统的不同模块之间不容易协调。</p><p><img src="/../img/bg1/posts/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E6%8F%92%E5%9B%BE.pngr" alt="在这里插入图片描述"></p><h2 id="六、合成复用原则"><a href="#六、合成复用原则" class="headerlink" title="六、合成复用原则"></a>六、合成复用原则</h2><p><strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</strong></p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p><img src="/../img/bg1/posts/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E6%8F%92%E5%9B%BE.png" alt="在这里插入图片描述"></p><h2 id="七、单一职责原则"><a href="#七、单一职责原则" class="headerlink" title="七、单一职责原则"></a>七、单一职责原则</h2><p>单一职责原则,全称Single Responsibility Principle, 简称SRP. A class should have only one reason to change 类发生更改的原因应该只有一个。</p><p><strong>一个类只干一件事，实现类要单一</strong></p><ul><li>提高类的可维护性和可读写性 一个类的职责少了，复杂度降低了，代码就少了，可读性也就好了，可维护性自然就高了。</li><li>提高系统的可维护性 系统是由类组成的，每个类的可维护性高，相对来讲整个系统的可维护性就高。当然，前提是系统的架构没有问题。</li><li>降低变更的风险 一个类的职责越多，变更的可能性就越大，变更带来的风险也就越大</li><li>如果在一个类中可能会有多个发生变化的东西，这样的设计会带来风险, 我们尽量保证只有一个可以变化，其他变化的就放在其他类中，这样的好处就是 <strong>提高内聚，降低耦合</strong> 。</li></ul><p><strong>单一职责与接口隔离的区别：</strong></p><ol><li><strong>单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离。</strong></li><li><strong>单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节； 而接口隔离原则主要约束接口，主要针对抽象，针对程序整体框架的构建。</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java复习：七大软件设计原则&quot;&gt;&lt;a href=&quot;#Java复习：七大软件设计原则&quot; class=&quot;headerlink&quot; title=&quot;Java复习：七大软件设计原则&quot;&gt;&lt;/a&gt;Java复习：七大软件设计原则&lt;/h1&gt;&lt;p&gt;在软件开发中，为了提高软件系统的可维</summary>
      
    
    
    
    
    <category term="设计原则" scheme="http://121.43.167.55/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java复习：单例模式</title>
    <link href="http://121.43.167.55/2023/060759968.html"/>
    <id>http://121.43.167.55/2023/060759968.html</id>
    <published>2023-06-07T11:20:18.000Z</published>
    <updated>2023-06-07T11:41:41.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磨人的单例！嗯？这还是我认识的那个单例吗？"><a href="#磨人的单例！嗯？这还是我认识的那个单例吗？" class="headerlink" title="磨人的单例！嗯？这还是我认识的那个单例吗？"></a>磨人的单例！嗯？这还是我认识的那个单例吗？</h2><h2 id="各位看官里边请："><a href="#各位看官里边请：" class="headerlink" title="各位看官里边请："></a>各位看官里边请：</h2><p><strong>（摘要）做了这么多手段，真的就拿单例没办法了吗？(枚举大哥麻烦靠边点，小心误伤！)</strong></p><p><strong>看我暴力反射！！</strong></p><p><strong>看我序列化！</strong></p><p><img src="/../img/bg1/posts/idea%E4%B8%8A%E5%8F%B7%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330154842153"></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例设计模式是创建型模式其中之一，创建型模式的主要关注点是“怎样创建对象”，主要的特点是将对象的创建与使用分离，这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工厂模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h2><p>单例模式（Singletons Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><blockquote><p>​<strong>饿汉式：类加载就会导致该单实例对象被创建</strong></p><p>​<strong>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</strong></p></blockquote><p><img src="/../img/bg1/posts/%E6%9C%89bug%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330155105891"></p><h2 id="1-1、懒汉式（线程不安全）"><a href="#1-1、懒汉式（线程不安全）" class="headerlink" title="1.1、懒汉式（线程不安全）"></a>1.1、懒汉式（线程不安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程不安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singletons</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singletons</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singletons instance;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singletons <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singletons</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可得：该方式在成员位置声明Singletons类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用<code>getInstance()</code>方法获取Singletons类的对象的时候才创建Singletons类的对象，这样就实现了懒加载的效果。</p><p>但是，如果是多线程环境，会出现线程安全问题。</p><h2 id="1-2、懒汉式（线程安全）"><a href="#1-2、懒汉式（线程安全）" class="headerlink" title="1.2、懒汉式（线程安全）"></a>1.2、懒汉式（线程安全）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程安全</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singletons</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singletons</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">// 在成员变量位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singletons instance;<br>    <br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singletons <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singletons</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>synchronized关键字：该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在<code>getInstance()</code>方法上添加了synchronized关键字，同步之后导致该方法的执行效果特别低。</p><p>由此可见是在对象创建初始化的时候会出现线程安全问题，一旦对象创建完成则不会有线程安全问题。</p><h2 id="1-3、懒汉式（双重检查锁）"><a href="#1-3、懒汉式（双重检查锁）" class="headerlink" title="1.3、懒汉式（双重检查锁）"></a>1.3、懒汉式（双重检查锁）</h2><p>提到加锁，不得不说到读与写，线程安全主要在于写操作，读操作则不会，所以我们可以再次调整加锁的时机。</p><p>由此，<strong>双重检查锁模式</strong>它来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123; <br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给对象加上volatile关键字可以保证可见性和有序性</span><br><span class="hljs-comment">  * private static volatile Singleton instance;</span><br><span class="hljs-comment">  */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">// 对外提供公共的方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 如果instance不为null，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 同步代码块</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">// 抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此，单例、性能、线程安全问题都可以保证，但是在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p> <code>volatile</code> 关键字可以解决这个问题，在上述代码成员变量中注释, <code>volatile</code> 关键字可以保证可见性和有序性。添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p><h2 id="1-4、懒汉式（静态内部类）"><a href="#1-4、懒汉式（静态内部类）" class="headerlink" title="1.4、懒汉式（静态内部类）"></a>1.4、懒汉式（静态内部类）</h2><p><strong>看我终极方式！！！</strong></p><p><strong>此方法有些取巧，但又完全符合规则，非常精致巧妙地处理了单例、性能、线程安全等等问题，各位看官请：</strong></p><p>由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。</p><p>静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第一次加载Singleton类时不会去初始化INSTANCE，</span><br><span class="hljs-comment">     * 只有第一次调用getInstance，虚拟机加载SingletonHolder</span><br><span class="hljs-comment">     * 并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>是吧！就是这么简单！</strong></p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。</p><p>在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><p><img src="/../img/bg1/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%94%B9bug%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330155153992"></p><h2 id="2-1饿汉式（王炸！枚举方式）"><a href="#2-1饿汉式（王炸！枚举方式）" class="headerlink" title="2.1饿汉式（王炸！枚举方式）"></a>2.1饿汉式（王炸！枚举方式）</h2><p>枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>就是这么简单粗暴！</strong></p><h2 id="2-2饿汉式（静态变量）"><a href="#2-2饿汉式（静态变量）" class="headerlink" title="2.2饿汉式（静态变量）"></a>2.2饿汉式（静态变量）</h2><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。</p><p>但是！如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 成员位置声明Singleton类型的静态变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-comment">// 对外提供公共的方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3饿汉式（静态代码块）"><a href="#2-3饿汉式（静态代码块）" class="headerlink" title="2.3饿汉式（静态代码块）"></a>2.3饿汉式（静态代码块）</h2><p>该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。</p><p>所以和饿汉式的静态变量方式基本上一样，该方式也存在内存浪费问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 成员位置声明Singleton类型的静态变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">// 静态代码块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 对外提供公共的方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你以为到这里就结束了吗？</p><p>不  不  不  ！！</p><p>做了这么多手段，真的就拿单例没办法了吗？(<strong>枚举大哥麻烦靠边点，小心误伤！</strong>)</p><p>看我暴力反射！！</p><p>看我序列化！</p><p><img src="/../img/bg1/posts/%E6%94%B9bug%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330155315886"></p><h2 id="3-1破坏单例模式"><a href="#3-1破坏单例模式" class="headerlink" title="3.1破坏单例模式"></a>3.1破坏单例模式</h2><p>怎么使得单例类（Singleton）可以创建多个对象，枚举方式除外。</p><p><strong>注意：枚举方式不会有以下问题。</strong></p><ul><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Singleton类的字节码对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Singleton.class;<br>        <span class="hljs-comment">// 获取Singleton类的私有无参构造方法对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>        <span class="hljs-comment">// 取消访问检查</span><br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 创建Singleton类的对象Single1</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">Single1</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br>        <span class="hljs-comment">// 创建Singleton类的对象Single2</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">Single2</span> <span class="hljs-operator">=</span> (Singleton) constructor.newInstance();<br><br>        <span class="hljs-comment">// 判断通过反射创建的两个Singleton对象是否是同一个对象</span><br>        System.out.println(Single1 == Single2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是<code>false</code>，成功破坏！</p></li><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 往文件中写对象</span><br>        <span class="hljs-comment">// writeObject2File();</span><br>        <span class="hljs-comment">// 从文件中读取对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">Single1</span> <span class="hljs-operator">=</span> readObjectFromFile();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">Single2</span> <span class="hljs-operator">=</span> readObjectFromFile();<br><br>        <span class="hljs-comment">// 判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(Single1 == Single2);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建对象输入流对象</span><br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\t.txt&quot;</span>));<br>        <span class="hljs-comment">// 第一个读取Singleton对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取Singleton类的对象</span><br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-comment">// 创建对象输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:\\t.txt&quot;</span>));<br>        <span class="hljs-comment">// 写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果是<code>false</code>，成功破坏！</p></li></ul><h2 id="3-2解决问题"><a href="#3-2解决问题" class="headerlink" title="3.2解决问题"></a>3.2解决问题</h2><ul><li><p>序列化、反序列方式解决方法</p><p>Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，</p><p>如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-comment">// 私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 解决序列化反序列化破解单例模式</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">outerHandle</span> <span class="hljs-operator">=</span> passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> readObject0(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readObject0</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br>    <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (tc) &#123;<br>...<br><span class="hljs-keyword">case</span> TC_OBJECT:<br><span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<br>                <span class="hljs-comment">// 重点查看readOrdinaryObject方法</span><br>...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-type">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>...<br><span class="hljs-comment">// isInstantiable 返回true，</span><br>    <span class="hljs-comment">// 执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-literal">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 </span><br>    <span class="hljs-comment">// desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    <span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，</span><br>        <span class="hljs-comment">// 将返回值赋值给rep变量</span><br>        <br>    <span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，</span><br>        <span class="hljs-comment">// 继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rep</span> <span class="hljs-operator">=</span> desc.invokeReadResolve(obj);<br>     ...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 反射破解单例模式</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">// 对外提供静态方法获取该对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接不干了！当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><p><img src="/../img/bg1/posts/%E5%8F%91%E5%B8%83%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330155400815"></p><h2 id="3-3-JDK源码解析-Runtime类"><a href="#3-3-JDK源码解析-Runtime类" class="headerlink" title="3.3 JDK源码解析-Runtime类"></a>3.3 JDK源码解析-Runtime类</h2><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取Runtime类对象</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><br>        <span class="hljs-comment">// 返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">// 返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">// 创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        <span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">// 获取命令执行后的结果，通过输入流获取</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br>        <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/bg1/posts/%E5%8F%91%E5%B8%83%E8%A1%A8%E6%83%85%E5%8C%85.png" alt="image-20230330155400815"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;磨人的单例！嗯？这还是我认识的那个单例吗？&quot;&gt;&lt;a href=&quot;#磨人的单例！嗯？这还是我认识的那个单例吗？&quot; class=&quot;headerlink&quot; title=&quot;磨人的单例！嗯？这还是我认识的那个单例吗？&quot;&gt;&lt;/a&gt;磨人的单例！嗯？这还是我认识的那个单例吗？&lt;/</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://121.43.167.55/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java实时监听数据库变化</title>
    <link href="http://121.43.167.55/2023/051024438.html"/>
    <id>http://121.43.167.55/2023/051024438.html</id>
    <published>2023-05-10T12:10:54.000Z</published>
    <updated>2023-05-10T12:22:18.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近遇到一个需求，需要监听数据库中的数据变化，并及时通知后端服务做出相应的处理。本文将介绍如何使用四种方式实现监听MySQL数据库中的数据变化并通知后端服务的功能，包括：</p><ul><li>轮询方式</li><li>使用触发器方式</li><li><code>MySQL</code>自带的<code>Binlog</code>方式</li><li>使用开源的Canal工具</li></ul><h2 id="一、轮询方式"><a href="#一、轮询方式" class="headerlink" title="一、轮询方式"></a>一、轮询方式</h2><p>轮询方式是指定时查询MySQL数据库中的某个表，然后与上一次查询结果进行比较，从而得知是否有数据发生变化。</p><p>它通过定期查询MySQL数据库的方式来检测数据变化。我们可以在后端服务中使用定时器，在一定时间间隔内轮询MySQL数据库，从而检测数据变化并做出相应的动作。</p><p>具体实现步骤如下：</p><ul><li>在后端服务中使用定时器，定时轮询MySQL数据库。</li><li>定时器触发时，执行SQL语句查询MySQL数据库中的数据，比较查询结果与之前保存的结果，判断是否有变化。</li><li>如果数据发生变化，则通知后端服务做出相应的动作。</li></ul><p>轮询方法的优点是实现简单，不需要额外的插件或配置，适用于数据变化频率较低的场景。但是存在以下几个问题：</p><ul><li>浪费资源：需要不断地查询数据库，即使数据库中没有数据变化，也会一直消耗资源。</li><li>延迟高：轮询的时间间隔一般比较大，因此可能会存在较大的延迟。</li></ul><p>对于高并发场景下实时性要求较高的情况不适用，轮询方法存在一定的性能问题，轮询间隔过短会增加数据库负担，轮询间隔过长又可能会错过数据变化。</p><h2 id="二、使用触发器方式"><a href="#二、使用触发器方式" class="headerlink" title="二、使用触发器方式"></a>二、使用触发器方式</h2><p>这种方法是在MySQL数据库中使用触发器，<strong>触发器是一种数据库对象</strong>，在数据插入或更新时触发相应的事件，并将事件信息传递给后端服务。这种方法可以保证实时性，但是需要在MySQL数据库中添加触发器，增加了系统复杂度。此外，触发器的数量和复杂度也会对数据库性能造成影响。</p><p>这种方法的优点是可以减少对数据库的轮询次数，提高了性能，同时也可以更及时地获得数据变化的通知。但是，它的缺点是比较难以维护，容易导致性能问题，因为触发器的开销很大。</p><p>具体实现步骤如下：</p><ul><li>在MySQL数据库中创建触发器，定义触发器的类型和事件，以及后续操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER my_trigger AFTER INSERT ON my_table<br>FOR EACH ROW<br>BEGIN<br>    -- 在此处编写通知后端服务的代码<br>END;<br><br></code></pre></td></tr></table></figure><ul><li>当触发器中定义的事件发生时，MySQL数据库会自动触发后续操作，向后端服务发送通知。</li></ul><p>基于触发器的方法的优点是能够实时检测数据变化，并且不需要在后端服务中进行轮询操作。但是，该方法需要在MySQL数据库中创建触发器，需要对MySQL数据库有一定的了解和操作权限，并且在高并发的场景下可能存在性能问题。</p><h2 id="三、MySQL自带的Binlog方式"><a href="#三、MySQL自带的Binlog方式" class="headerlink" title="三、MySQL自带的Binlog方式"></a>三、MySQL自带的Binlog方式</h2><p>使用MySQL的binlog日志：MySQL的binlog日志记录了数据库的所有修改操作，可以通过读取binlog日志来获取数据库中的数据变化，并发送通知到后端服务。</p><p>这种方法是通过解析MySQL Binlog日志文件中的数据变更事件，识别和提取感兴趣的事件，并通知后端服务。这种方法可以保证实时性，且不需要在MySQL数据库中添加额外的触发器或表，但需要对MySQL Binlog日志文件进行解析，实现起来较为复杂。</p><p>该方式具有以下优点：</p><ul><li>实时性高：可以实时获取数据变化。</li><li>精度高：可以记录到具体的数据变化操作。</li><li>避免对数据库的轮询操作</li></ul><p><strong>具体实现步骤如下：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 开启binlog：在MySQL配置文件中，将`log_bin`参数设置为ON。<br><br>2. 使用MySQL的`mysqlbinlog`命令行工具将binlog中的内容读取出来，并进行解析。<br><br>3. 解析binlog中的内容，判断数据变更的类型，如果是插入、更新或删除，则触发对应的回调函数，通知后端服务进行相应的处理。<br></code></pre></td></tr></table></figure><p>需要注意的是，使用binlog监听MySQL数据变更需要注意以下问题：</p><ol><li>对MySQL的性能有一定影响，因为binlog记录了所有的数据变更操作。</li><li>binlog中的内容是以二进制形式存储的，需要进行解析。解析过程需要一定的技术功底。</li><li>binlog只记录了数据变更操作，没有记录查询操作，如果需要监听查询操作，需要使用其他方式。</li><li>binlog只记录了当前MySQL实例中的数据变更操作，如果需要监听多个MySQL实例，需要分别监听每个实例的binlog。</li><li>不稳定：MySQL的Binlog并不稳定，可能会出现丢失或损坏的情况。</li></ol><p>综上所述，使用binlog实现MySQL数据变更的监听需要一定的技术功底和额外的开销，但是可以实现较为精确的数据变更监听，并且支持对数据变更进行回滚等操作。在一些对数据一致性要求较高的场景中，可以考虑使用这种方式。</p><h2 id="四、使用开源的Canal工具"><a href="#四、使用开源的Canal工具" class="headerlink" title="四、使用开源的Canal工具"></a>四、使用开源的Canal工具</h2><p> Canal是阿里巴巴开源的一款基于MySQL数据库的增量数据订阅和消费组件，可以将MySQL数据库的数据变更事件以消息的形式通知到后端服务，支持多种协议和多种编程语言。且相比从MySQL Binlog中解析法来说实现起来更为简便。</p><p>Canal通过读取MySQL的binlog日志来获取数据库中数据的变化情况，提供了高吞吐、低延迟、低侵入性的数据库增量订阅&amp;消费解决方案。</p><p>Canal的工作原理如下图所示：</p><p><img src="/../img/bg1/posts/Canal%E7%9B%91%E5%90%AC%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="img"></p><p>Canal架构图中，MySQL的binlog日志是Canal的数据源，Canal Server是数据消费者，将解析后的数据发送给下游的消费者进行处理。Canal Client是在业务系统中部署的，用于连接Canal Server，订阅指定的数据变更事件，接收Canal Server发送的数据变更事件，并将数据变更事件转换为Java对象。</p><p>Canal的优点：</p><ul><li>Canal能够对MySQL的数据进行精确的增量订阅，对MySQL的性能影响较小。</li><li>Canal能够将MySQL的数据变更事件以消息的形式进行订阅，适用于分布式架构。</li><li>Canal提供了多种消息传递协议和序列化协议，具有较高的可扩展性。</li><li>Canal具有较高的稳定性和可靠性，支持HA和负载均衡。</li><li>Canal是开源的，具有较高的社区活跃度和技术支持。</li></ul><p>Canal的缺点：</p><ul><li>Canal需要在业务系统中部署Canal Client，增加了部署和维护的难度。</li><li>Canal对MySQL的binlog日志的解析需要占用一定的资源，对MySQL的性能有一定的影响。</li><li>Canal的部署和维护需要一定的技术水平，对于小型项目来说可能过于复杂。</li></ul><p>Canal 的工作原理是模拟 MySQL 自身的复制机制。当有数据发生变化时，MySQL 会将该变化以二进制格式写入 binlog 日志中，Canal 会监听这个 binlog 日志，将其中的增量数据解析成对象，并发送给订阅者。</p><p>Canal 支持多种方式接入后端服务，包括 Kafka、RocketMQ、ActiveMQ 等，也可以通过 HTTP 接口直接获取数据。使用 Canal 监听 MySQL 数据库的数据变化，需要进行如下步骤：</p><h4 id="1、下载和安装-Canal-Server。"><a href="#1、下载和安装-Canal-Server。" class="headerlink" title="1、下载和安装 Canal Server。"></a>1、<strong>下载和安装 Canal Server</strong>。</h4><p>首先需要从 Canal 的 GitHub 上下载 Canal 的 Server 和 Client，地址为 <a href="https://github.com/alibaba/canal/releases%E3%80%82">https://github.com/alibaba/canal/releases。</a></p><p>选择最新版本，然后下载 Server 和 Client 压缩包，解压缩。</p><h4 id="2、配置-Canal-Server，包括-MySQL-数据库连接信息、Canal-监听的-binlog-位置等信息。"><a href="#2、配置-Canal-Server，包括-MySQL-数据库连接信息、Canal-监听的-binlog-位置等信息。" class="headerlink" title="2、配置 Canal Server，包括 MySQL 数据库连接信息、Canal 监听的 binlog 位置等信息。"></a>2、<strong>配置 Canal Server</strong>，包括 MySQL 数据库连接信息、Canal 监听的 binlog 位置等信息。</h4><p>在解压缩后的 Server 目录中，找到 conf 目录，编辑 instance.properties 文件，进行以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#################################################</span><br><span class="hljs-comment">## mysql serverId 实例名称</span><br><span class="hljs-string">canal.instance.mysql.slaveId</span> <span class="hljs-string">=</span> <span class="hljs-number">1234</span><br><br><span class="hljs-comment"># position info </span><br><span class="hljs-comment"># MySQL 地址和端口号</span><br><span class="hljs-string">canal.instance.master.address</span> <span class="hljs-string">=</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:3306</span><br><span class="hljs-string">canal.instance.master.journal.name</span> <span class="hljs-string">=</span>  <br><span class="hljs-string">canal.instance.master.position</span> <span class="hljs-string">=</span> <br><span class="hljs-string">canal.instance.master.timestamp</span> <span class="hljs-string">=</span> <br><br><span class="hljs-comment">#canal.instance.standby.address = </span><br><span class="hljs-comment">#canal.instance.standby.journal.name =</span><br><span class="hljs-comment">#canal.instance.standby.position = </span><br><span class="hljs-comment">#canal.instance.standby.timestamp = </span><br><br><span class="hljs-comment"># username/password</span><br><span class="hljs-comment"># MySQL 用户名和密码</span><br><span class="hljs-string">canal.instance.dbUsername</span> <span class="hljs-string">=</span> <span class="hljs-string">canal</span><br><span class="hljs-string">canal.instance.dbPassword</span> <span class="hljs-string">=</span> <span class="hljs-string">canal</span><br><span class="hljs-string">canal.instance.defaultDatabaseName</span> <span class="hljs-string">=</span> <span class="hljs-string">test</span><br><span class="hljs-string">canal.instance.connectionCharset</span> <span class="hljs-string">=</span> <span class="hljs-string">UTF-8</span><br><br><span class="hljs-comment"># table regex</span><br><span class="hljs-comment"># 指定需要监听的数据库和表</span><br><span class="hljs-string">canal.instance.filter.regex</span> <span class="hljs-string">=</span> <span class="hljs-string">.*\\..*</span><br><span class="hljs-comment"># table black regex</span><br><span class="hljs-string">canal.instance.filter.black.regex</span> <span class="hljs-string">=</span>  <br><br><span class="hljs-comment">#################################################</span><br></code></pre></td></tr></table></figure><p>address设置为mysql的连接地址，defaultDatabaseName设置为自己要监听的库名，如test。</p><p>在mysql命令行，创建一个新用户，作为slave</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> canal IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;canal&#x27;</span>;  <br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;canal&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-comment">-- GRANT ALL PRIVILEGES ON *.* TO &#x27;canal&#x27;@&#x27;%&#x27; ;</span><br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p>对应配置文件里的canal用户。到此配置完毕。</p><p>执行bin目录下的startup.sh</p><p>启动后可以在logs目录下查看日志。在example目录下的example.log，如果没有报错，说明启动成功。</p><h4 id="3、编写-Canal-客户端，订阅-Canal-Server-发送的增量数据，并处理数据。"><a href="#3、编写-Canal-客户端，订阅-Canal-Server-发送的增量数据，并处理数据。" class="headerlink" title="3、编写 Canal 客户端，订阅 Canal Server 发送的增量数据，并处理数据。"></a>3、<strong>编写 Canal 客户端</strong>，订阅 Canal Server 发送的增量数据，并处理数据。</h4><p>服务端启动完毕后，在客户端即可监听test库的变化。</p><p>新建一个java maven项目，pom.xml里添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.otter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>canal.client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;<br><span class="hljs-keyword">import</span> com.alibaba.otter.canal.protocol.Message;<br><br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A Camel Application</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainApp</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A main() so we can easily run these routing rules in our IDE</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">// 创建链接</span><br>        <span class="hljs-comment">// 设置canal server的ip和端口，端口默认为11111。</span><br>        <span class="hljs-comment">// example是和conf目录下的相对应</span><br>        <span class="hljs-type">CanalConnector</span> <span class="hljs-variable">connector</span> <span class="hljs-operator">=</span> CanalConnectors.newSingleConnector(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(AddressUtils.getHostIp(),<br>                <span class="hljs-number">11111</span>), <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">emptyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connector.connect();<br>            connector.subscribe(<span class="hljs-string">&quot;.*\\..*&quot;</span>);<br>            connector.rollback();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">totalEmptyCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span>;<br>            <span class="hljs-keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;<br>                 <span class="hljs-comment">// 获取指定数量的数据</span><br>                <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> connector.getWithoutAck(batchSize); <br>               <br>                <span class="hljs-type">long</span> <span class="hljs-variable">batchId</span> <span class="hljs-operator">=</span> message.getId();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> message.getEntries().size();<br>                <span class="hljs-keyword">if</span> (batchId == -<span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>) &#123;<br>                    emptyCount++;<br>                    System.out.println(<span class="hljs-string">&quot;empty count : &quot;</span> + emptyCount);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    emptyCount = <span class="hljs-number">0</span>;<br>                    <span class="hljs-comment">// System.out.printf(&quot;message[batchId=%s,size=%s] \n&quot;, batchId, size);</span><br>                    printEntry(message.getEntries());<br>                &#125;<br><br>                connector.ack(batchId); <span class="hljs-comment">// 提交确认</span><br>                <span class="hljs-comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span><br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;empty too many times, exit&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            connector.disconnect();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printEntry</span><span class="hljs-params">(List&lt;CanalEntry.Entry&gt; entrys)</span> &#123;<br>        <span class="hljs-keyword">for</span> (CanalEntry.Entry entry : entrys) &#123;<br>            <span class="hljs-keyword">if</span> (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry<br>                    .EntryType<br>                    .TRANSACTIONEND) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            CanalEntry.<span class="hljs-type">RowChange</span> <span class="hljs-variable">rowChage</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),<br>                        e);<br>            &#125;<br><br>            CanalEntry.<span class="hljs-type">EventType</span> <span class="hljs-variable">eventType</span> <span class="hljs-operator">=</span> rowChage.getEventType();<br>            System.out.println(String.format(<span class="hljs-string">&quot;================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,<br>                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),<br>                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),<br>                    eventType));<br><br>            <span class="hljs-keyword">for</span> (CanalEntry.RowData rowData : rowChage.getRowDatasList()) &#123;<br>                <span class="hljs-keyword">if</span> (eventType == CanalEntry.EventType.DELETE) &#123;<br>                    printColumn(rowData.getBeforeColumnsList());<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType == CanalEntry.EventType.INSERT) &#123;<br>                    printColumn(rowData.getAfterColumnsList());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;-------&gt; before&quot;</span>);<br>                    printColumn(rowData.getBeforeColumnsList());<br>                    System.out.println(<span class="hljs-string">&quot;-------&gt; after&quot;</span>);<br>                    printColumn(rowData.getAfterColumnsList());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printColumn</span><span class="hljs-params">(List&lt;CanalEntry.Column&gt; columns)</span> &#123;<br>        <span class="hljs-keyword">for</span> (CanalEntry.Column column : columns) &#123;<br>            System.out.println(column.getName() + <span class="hljs-string">&quot; : &quot;</span> + column.getValue() + <span class="hljs-string">&quot;    update=&quot;</span> + column.getUpdated());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上四种方法都可以实现对 MySQL 数据库中的数据变化进行监听和通知，不同的方法适用于不同的场景，可以根据实际情况选择最合适的方法。</p><p><strong>轮询方式</strong>和<strong>使用触发器方式</strong>相对简单，适合对数据变化的及时性和精确性要求不高的场景；**<code>Binlog</code>方式<strong>和</strong>Canal工具**则更加强大和灵活，适用于对数据变化的及时性和精确性要求比较高的场景。</p><p>在实际应用中，需要根据业务需求和技术实现难度进行选择。同时，为了确保系统的稳定性和数据安全，需要对监听和通知的过程进行充分的测试和安全评估。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近遇到一个需求，需要监听数据库中的数据变化，并及时通知后端服务做出相应的处理。本文将介绍如何使用四种方式实现监听MySQL数据库中的数据变</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://121.43.167.55/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用阿里云服务器搭建技术分享网站</title>
    <link href="http://121.43.167.55/2023/05105115.html"/>
    <id>http://121.43.167.55/2023/05105115.html</id>
    <published>2023-05-10T12:05:00.000Z</published>
    <updated>2023-06-07T11:41:41.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用云服务器搭建技术分享网站"><a href="#使用云服务器搭建技术分享网站" class="headerlink" title="使用云服务器搭建技术分享网站"></a>使用云服务器搭建技术分享网站</h1><p>域名和云服务器的配置信息如下：</p><ul><li>域名：<a href="http://www.yangsir2022.top/">www.yangsir2022.top</a></li><li>服务器：阿里云轻量级</li><li>系统镜像：CentOS 7.6</li><li>地域：华东1（杭州）</li><li>套餐配置：2核 vCPU|2GB 内存|50GB 高效云盘|3Mbps 限峰值带宽</li></ul><p><strong>做一件事，最难的是前期的准备和后期的总结归档，当你前期准备充分了，即便过程中遇到困难也会迎刃而解，后期总结清晰，即便再次遇到也毫无压力。</strong></p><p>这是我第二次搭建技术网站，相比较第一次对目标和流程更加的清晰，过程中遇到一些难点也能够清楚的定位到错误在哪里，想起之前第一次的时候之前一天踩一坑，坑坑不重样的囧态不经一笑。</p><p>之前采用的宝塔配置的云服务器，大家可以去试一下，不要太爽，直接可视化界面部署，但是对于Linux系统的认识没有帮助，所以这次我采用的纯指令方式一步步安装部署，也是再次熟悉一下Linux系统，当然也踩了几个坑，在下文中都已经填平，可以放心食用！！</p><p>操作目录：</p><p>[TOC]</p><h2 id="一、安全组设置"><a href="#一、安全组设置" class="headerlink" title="一、安全组设置"></a>一、安全组设置</h2><p><img src="/../img/%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%89%E5%85%A8%E7%BB%84.png" alt="image-20230502074759954"></p><p>首先是服务器安全组的设置，主要是看服务器厂家的设置，需要开放80端口供Nginx使用。</p><h2 id="二、云服务器的配置"><a href="#二、云服务器的配置" class="headerlink" title="二、云服务器的配置"></a>二、云服务器的配置</h2><p>目标：完成服务器环境配置，使得本地文件推送到服务器能成功运行。</p><p><strong>注意负责相关文件夹以及文件创建的用户，我在下方都有标注，创建文件的用户不也一样，相关权限也不一样，会直接影响环境的配置！！！</strong></p><p><strong>技术点：</strong></p><ul><li>Linux指令</li><li>Nginx配置</li><li>nodejs配置</li><li>Git及其仓库配置</li></ul><h4 id="1、本地博客文件存放目录（root用户）"><a href="#1、本地博客文件存放目录（root用户）" class="headerlink" title="1、本地博客文件存放目录（root用户）"></a>1、本地博客文件存放目录（root用户）</h4><p>我的存放路径：home&#x2F;www&#x2F;blog</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">按序操作指令</span><br>cd /home<br>mkdir www<br>cd /www<br>mkdir /blog<br><br></code></pre></td></tr></table></figure><h4 id="2、Nginx配置（root用户）"><a href="#2、Nginx配置（root用户）" class="headerlink" title="2、Nginx配置（root用户）"></a>2、Nginx配置（root用户）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用yum安装</span><br>yum install -y nginx<br><br><span class="hljs-comment"># 开启服务器</span><br>systemctl start nginx<br><br><span class="hljs-comment"># 设置开机自启</span><br>systemctl <span class="hljs-built_in">enable</span> nginx<br><br><span class="hljs-comment"># 测试：使用ip地址访问出现CentOS界面表示安装成功！</span><br><br></code></pre></td></tr></table></figure><p>此时访问的是Nginx的默认页面，我们需要在Nginx内部设置访问我们自己的博客文件，找到Nginx的配置文件：<code>etc/nginx/nginx.conf</code>进行修改如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>        listen       80;<br>        listen       [::]:80;<br>        <span class="hljs-comment"># 修改server_name 为自己域名，如果暂时不可用就填公网ip</span><br>        server_name  www.yangsir2022.top; <br>        <span class="hljs-comment"># 修改root 为上文创建的博客文件目录</span><br>        root         /home/www/blog;<br><br>        <span class="hljs-comment"># Load configuration files for the default server block.</span><br>        include /etc/nginx/default.d/*.conf;<br><br>        error_page 404 /404.html;<br>        location = /404.html &#123;<br>        &#125;<br><br>        error_page 500 502 503 504 /50x.html;<br>        location = /50x.html &#123;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="3、Nodejs配置（root用户）"><a href="#3、Nodejs配置（root用户）" class="headerlink" title="3、Nodejs配置（root用户）"></a>3、Nodejs配置（root用户）</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 更换安装源</span><br>curl -sL https://rpm.nodesource.com/setup_10.x | bash -<br><br><span class="hljs-comment"># 使用yum安装</span><br>yum install -y nodejs<br><br><span class="hljs-comment"># 测试是否成功，出现版本号即表示成功</span><br>node -v<br>npm -v<br><br></code></pre></td></tr></table></figure><h4 id="3、Git及其仓库配置（root转git用户）"><a href="#3、Git及其仓库配置（root转git用户）" class="headerlink" title="3、Git及其仓库配置（root转git用户）"></a>3、Git及其仓库配置（root转git用户）</h4><p>目标：使用Git将本地的博客文件推送到云服务器，连接方式：<code>ssh</code></p><p><strong>①安装Git程序（root用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用yum安装</span><br>yum install git<br><br><span class="hljs-comment"># 测试：出现如下版本号即表示安装成功</span><br><span class="hljs-comment"># （git version 1.8.3.1）</span><br>git --version<br><br></code></pre></td></tr></table></figure><p><strong>②新建git用户（root用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 创建git用户</span><br>adduser -m  git<br><br><span class="hljs-comment"># 修改用户sudoers文件权限，方便编辑</span><br><span class="hljs-built_in">chmod</span> 740 /etc/sudoers<br><br><span class="hljs-comment"># 编辑文件</span><br><span class="hljs-comment"># 注意：字母i键进行编辑、退出方式（按Esc键，再 :wq 保存退出）</span><br><span class="hljs-comment"># 如果误操作Ctrl+S使用Ctrl+Q恢复</span><br>vi /etc/sudoers<br><br></code></pre></td></tr></table></figure><p><strong>③添加<code>git  ALL=(ALL) ALL</code>使得 git 用户拥有 sudo 管理员权限（root用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">## Syntax:</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## userMACHINE=COMMANDS</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## The COMMANDS section may have other options added to it.</span><br><span class="hljs-comment">##</span><br><span class="hljs-comment">## Allow root to run any commands anywhere </span><br>rootALL=(ALL) ALL<br><span class="hljs-comment"># 在此处添加</span><br>git     ALL=(ALL)       ALL<br><br><span class="hljs-comment">## Allows members of the &#x27;sys&#x27; group to run networking, software, </span><br><span class="hljs-comment">## service management apps and more.</span><br><span class="hljs-comment"># %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS</span><br><br></code></pre></td></tr></table></figure><p>在 Linux 系统中，只有拥有管理员权限的用户才能执行一些需要特殊权限的操作，例如修改系统文件或者安装软件等。通常，用户需要使用 <code>sudo</code> 命令来获取临时的管理员权限，但是默认情况下，只有在 <code>/etc/sudoers</code> 文件中被明确授权的用户才能使用 <code>sudo</code> 命令。</p><p>在 <code>/etc/sudoers</code> 文件中添加 <code>Git ALL=(ALL) ALL</code> 的目的是将 <code>Git</code> 用户加入到 sudoers 组中，从而使该用户能够使用 <code>sudo</code> 命令以管理员权限执行系统命令。注意，对于任何修改 <code>/etc/sudoers</code> 文件的操作，都需要使用 <code>visudo</code> 命令进行编辑，以确保语法正确且避免因为语法错误导致系统安全问题。</p><p><strong>④改回权限（root用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> 400 /etc/sudoers<br></code></pre></td></tr></table></figure><p><strong>⑤设置git用户的密码（root用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 设置git用户密码</span><br><span class="hljs-comment"># 界面不会有显示，直接输入后回车，会提示输入两次</span><br>passwd git <br><br></code></pre></td></tr></table></figure><p><strong>⑥切换到 git 用户，在 ~ 目录创建.ssh文件夹做生成密匙的前期准备（root转git用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 转到git用户</span><br>su git<br><br><span class="hljs-comment"># 切换到~目录</span><br><span class="hljs-built_in">cd</span> ~<br><br><span class="hljs-comment"># 创建.ssh公钥密匙文件夹</span><br><span class="hljs-built_in">mkdir</span> .ssh<br><br><span class="hljs-comment"># 切换进.ssh文件夹</span><br><span class="hljs-built_in">cd</span> /.ssh<br><br></code></pre></td></tr></table></figure><p><strong>⑦生成公钥密匙文件（git用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 运行以下指令后.ssh文件夹会有两个文件，分别是id_rsa密匙 和 id_rsa.pub公钥</span><br>ssh-keygen<br><br></code></pre></td></tr></table></figure><p><strong>⑧复制一份公钥文件 id_rsa.pub 到当前目录 并改名 authorized_keys（git用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br><span class="hljs-built_in">cp</span> id_rsa.pub authorized_keys<br><br></code></pre></td></tr></table></figure><p><strong>⑨权限修改并测试本地ssh连接云服务器（本地）（git用户）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br><span class="hljs-built_in">chmod</span> 600 ~/.ssh/authorized_keys<br><span class="hljs-built_in">chmod</span> 700 ~/.ssh<br><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># xxx.xxx.xxx.xxx替换为公网ip</span><br><span class="hljs-comment"># 当你看到Welcome to Alibaba Cloud Elastic Compute Service !</span><br><span class="hljs-comment"># 表示连接成功</span><br>ssh -v git@xxx.xxx.xxx.xxx<br><br></code></pre></td></tr></table></figure><p><strong>⑩创建<code>git</code>的仓库，新建钩子文件<code>post-receive</code>（git用户）。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~<br>git init --bare blog.git<br><br><span class="hljs-comment"># 新建钩子文件post—receive</span><br><span class="hljs-comment"># 编辑文件</span><br><span class="hljs-comment"># 注意：字母i键进行编辑、退出方式（按Esc键，再 :wq 保存退出）</span><br><span class="hljs-comment"># 如果误操作Ctrl+S使用Ctrl+Q恢复</span><br>vi ~/blog.git/hooks/post-receive<br><br><span class="hljs-comment"># 设置Git工作树（工作目录）和 git仓库的位置</span><br>git --work-tree=/home/www/blog --git-dir=/home/git/blog.git checkout -f<br><br><span class="hljs-comment"># 退出之后赋予可执行权限</span><br><span class="hljs-built_in">chmod</span> +x ~/blog.git/hooks/post-receive<br><br></code></pre></td></tr></table></figure><p><code>git --work-tree=/home/www/blog --git-dir=/home/git/blog.git checkout -f</code>这个命令的作用是将git仓库中的代码强制检出到工作目录中。具体来说：</p><ul><li><code>--work-tree=/home/www/blog</code>指定了工作目录，也就是代码将要被检出到哪里。</li><li><code>--git-dir=/home/git/blog.git</code>指定了git仓库的位置，也就是代码从哪个git仓库中被检出。</li><li><code>checkout</code>命令用于将git仓库中的代码检出到工作目录中。</li><li><code>-f</code>选项表示强制检出，即如果工作目录中已经有一些修改了的文件，也会被覆盖。</li></ul><p><img src="/../img/git%E9%85%8D%E7%BD%AE.png" alt="image-20230502121143164"></p><p><strong>关于云服务器添加SSL证书和配置https的方法，由于篇幅原因，请移步我的主页觅食！！</strong></p><p><strong>至此，云服务器配置完成！下面配置本地环境</strong>！</p><h2 id="三、本地环境的配置"><a href="#三、本地环境的配置" class="headerlink" title="三、本地环境的配置"></a>三、本地环境的配置</h2><p>目标：完成本地环境配置，使得可以在成功编译并运行推送。</p><p><strong>技术点：</strong></p><ul><li>Windows环境Git及其仓库配置</li><li>nodejs配置</li><li>hexo配置</li><li>本地部署推送</li></ul><h4 id="1、Windows环境Git及其仓库配置"><a href="#1、Windows环境Git及其仓库配置" class="headerlink" title="1、Windows环境Git及其仓库配置"></a>1、Windows环境Git及其仓库配置</h4><p>Git官网下载速度比较慢，可以去阿里镜像下载：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/">点击我进入阿里巴巴Git镜像下载</a></p><p>关于Git安装教程请参考：<a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html">点击我进入Git安装详细教程</a>，这篇文章讲的非常详细。</p><h4 id="2、nodejs配置"><a href="#2、nodejs配置" class="headerlink" title="2、nodejs配置"></a>2、nodejs配置</h4><p>关于nodejs的配置，推荐使用nvm管理nodejs，这样可以让你有多个版本nodejs，并且不冲突，非常丝滑！！</p><p>可以参考这篇文章：[点击我进入nvm和node的下载配置](<a href="https://blog.csdn.net/JJ_Smilewang/article/details/127823953#:~:text=1.%E9%A6%96%E5%85%88%E5%9C%A8NVM%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E6%96%B0%E5%BB%BA%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9node_global%E5%92%8Cnode_cache">https://blog.csdn.net/JJ_Smilewang/article/details/127823953#:~:text=1.首先在NVM的安装目录新建两个文件夹node_global和node_cache</a> 2.创建完两个文件夹后，在cmd窗口中输入以下命令（两个路径即是两个文件夹的路径）： npm,config set prefix “D%3ANVMnode_global”)</p><h4 id="3、hexo配置"><a href="#3、hexo配置" class="headerlink" title="3、hexo配置"></a>3、hexo配置</h4><p>关于hexo的配置建议参考hexo脚本网站：<a href="https://hexoscript.gitbook.io/hexo-script/v/1.3-1/">点击我进入hexo脚本自动化配置</a> 非常详细。</p><h4 id="4、本地部署推送"><a href="#4、本地部署推送" class="headerlink" title="4、本地部署推送"></a>4、本地部署推送</h4><p>修改hexoblog下的_config.yml文件最下方的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">git@121.43.167.55:/home/git/blog.git</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>最后开启hexo三剑客：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p><h4 id="好了，本次的云服务技术分享网站搭建就到这里了"><a href="#好了，本次的云服务技术分享网站搭建就到这里了" class="headerlink" title="好了，本次的云服务技术分享网站搭建就到这里了"></a>好了，本次的云服务技术分享网站搭建就到这里了</h4><h3 id="光阴者，百代之过客也，唯奋力奔跑者，方能生风起时！"><a href="#光阴者，百代之过客也，唯奋力奔跑者，方能生风起时！" class="headerlink" title="光阴者，百代之过客也，唯奋力奔跑者，方能生风起时！"></a>光阴者，百代之过客也，唯奋力奔跑者，方能生风起时！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用云服务器搭建技术分享网站&quot;&gt;&lt;a href=&quot;#使用云服务器搭建技术分享网站&quot; class=&quot;headerlink&quot; title=&quot;使用云服务器搭建技术分享网站&quot;&gt;&lt;/a&gt;使用云服务器搭建技术分享网站&lt;/h1&gt;&lt;p&gt;域名和云服务器的配置信息如下：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    
    <category term="云服务器" scheme="http://121.43.167.55/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Bean的生命周期和循环依赖</title>
    <link href="http://121.43.167.55/2022/041654623.html"/>
    <id>http://121.43.167.55/2022/041654623.html</id>
    <published>2022-04-16T08:25:52.000Z</published>
    <updated>2023-06-07T11:41:41.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBean的生命周期与循环依赖"><a href="#SpringBean的生命周期与循环依赖" class="headerlink" title="SpringBean的生命周期与循环依赖"></a>SpringBean的生命周期与循环依赖</h1><p>&amp;emsp;&amp;emsp;<strong>————–具体 Spring 源码等有时间了再贴上来，请见谅！————–</strong></p><p>&amp;emsp;&amp;emsp;Bean的生命周期主要有四个阶段：1.实例化–&gt; 2.属性填充–&gt; 3.初始化Bean –&gt; 4.销毁Bean**</p><p><img src="/../img/bg1/posts/Springbean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h2 id="1-实例化Bean"><a href="#1-实例化Bean" class="headerlink" title="1.实例化Bean"></a>1.实例化Bean</h2><ol><li>当用户端请求一个尚未初始化的 bean 时，或者初始化 bean 的时候需要注入另一个依赖的 bean</li><li>Spring 容器启动进行扫描,把BeanName转换成BeanDefinition对象,放入BeanDefinitionMap</li><li>遍历做一系列的验证(是否单例、是否延迟加载、是否抽象)</li><li>去单例池中查是否存在,去二级缓存查是否存在,如果都没有,准备创建Bean</li><li>推断构造方法，通过反射实例化Java对象</li></ol><h2 id="2-属性填充"><a href="#2-属性填充" class="headerlink" title="2.属性填充"></a>2.属性填充</h2><ol><li>Bean实例创建出来后，接着就是给这个Bean对象进行属性填充，也就是注入这个Bean依赖的其它Bean对象。</li><li>如果支持循环依赖,生成当前Java对象的ObjectFactory对象存到二级缓存中,进行属性填充(自动注入)。</li></ol><p>&amp;emsp;&amp;emsp;<strong>注意：默认支持解决 set 方式的循环依赖，而构造方法注入 Bean 依赖产生的循环依赖不能解决，因为构造方式注入会先加载属性依赖，而这个时候依赖的 bean 还没有创建。</strong></p><h2 id="3-初始化bean"><a href="#3-初始化bean" class="headerlink" title="3.初始化bean"></a>3.初始化bean</h2><ol><li><p>调用实现的Aware接口的方法，如果实现了BeanNameAware接口可以获取到BeanName；如果实现了BeanFactoryAware接口可以获取到对象BeanFactory。(Spring会检测该对象是否实现了Aware接口，通过Aware类型的接口，可以拿到Spring容器的一些资源。)</p></li><li><p>执行BeanPostProcessor的前置处理方法postProcessBeforeInitialization(),对bean进行一些自定义的前置处理。</p></li><li><p>调用init初始化方法，(判断bean是否实现了initializingBean接口，如果实现了将会调用InitializingBean的afterPropertiesSet()初始化方法。如果XML中配置了init-method属性，会调⽤对应的初始化）。</p></li><li><p>执行BeanPostProcessor的后置处理方法postProcessAfterInitializtion()。（在此方法执行后会完成AOP的代理）。</p></li><li><p>初始化完成之后会将这个 bean 放入单例池。</p></li></ol><h2 id="4-销毁bean"><a href="#4-销毁bean" class="headerlink" title="4.销毁bean"></a>4.销毁bean</h2><ul><li>初始化完成后，Bean就成功创建了，之后就可以使用这个Bean。</li><li>当Bean不再需要时，就会进行销毁。</li><li>Spring容器关闭时调用DisposableBean的destory()方法。</li></ul><h1 id="Bean的循环依赖"><a href="#Bean的循环依赖" class="headerlink" title="Bean的循环依赖"></a>Bean的循环依赖</h1><ol><li><p>spring进行扫描-&gt;反射后封装成 X 的beanDefinition对象-&gt;放入beanDefinitionMap</p></li><li><p>遍历map-&gt;验证（是否单例、是否延迟加载、是否抽象）</p></li><li><p>推断构造方法-&gt;准备开始进行实例</p></li><li><p>去单例池中查，如果没有-&gt;去二级缓存中找，没有提前暴露-&gt;生成一个objectFactory对象暴露到二级缓存中</p></li><li><p>属性注入，发现依赖Y-&gt;此时Y开始它的生命周期直到属性注入，发现依赖X</p></li><li><p>X又走一遍生命周期，当走到去二级缓存中找的时候找到了 Y 的objectFactory，完成依赖注入</p></li><li><p>往Y中注入X的objectFactory对象-&gt;完成循环依赖。</p></li></ol><p><strong>1、为什么要使用X的objectFacory对象而不是直接使用X对象？</strong><br>利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象</p><p><strong>2、是不是只能支持单例(scope&#x3D;singleton)而不支持原型(scope&#x3D;prototype)？</strong><br>是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&gt;依赖-&gt;创建-&gt;依赖-&gt;…。</p><p><strong>3、循环依赖是不是只支持非构造方法？</strong><br>是。类似死锁问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBean的生命周期与循环依赖&quot;&gt;&lt;a href=&quot;#SpringBean的生命周期与循环依赖&quot; class=&quot;headerlink&quot; title=&quot;SpringBean的生命周期与循环依赖&quot;&gt;&lt;/a&gt;SpringBean的生命周期与循环依赖&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://121.43.167.55/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息丢失</title>
    <link href="http://121.43.167.55/2022/041412090.html"/>
    <id>http://121.43.167.55/2022/041412090.html</id>
    <published>2022-04-14T08:24:54.000Z</published>
    <updated>2023-06-07T11:41:41.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ消息丢失"><a href="#RabbitMQ消息丢失" class="headerlink" title="RabbitMQ消息丢失"></a>RabbitMQ消息丢失</h1><p>消息从生产到消费经过三个环节： 生产–&gt;MQ Broker –&gt; 消费  这三个环节都有丢失消息的可能。 </p><p><img src="/../img/bg1/posts/RabbitMQ%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png"></p><h2 id="一、生产者丢失消息"><a href="#一、生产者丢失消息" class="headerlink" title="一、生产者丢失消息"></a>一、生产者丢失消息</h2><p>&amp;emsp;&amp;emsp;原因：网络传输不稳定，从生产者到MQ的传输过程中，MQ未收到消息，而生产者认为任务完成不会重复发送，从而导致消息丢失。有两种方式可以解决该问题：事务机制和confirm通知机制。</p><h3 id="方式一：事务机制"><a href="#方式一：事务机制" class="headerlink" title="方式一：事务机制"></a>方式一：事务机制</h3><p>&amp;emsp;&amp;emsp;RabbitMQ提供了事务功能，生产者发送消息之前开启事务 channel.txSelect，然后发送消息，如果消息没有成功接收则报异常，此时回滚事务，channel.txRollback，然后重试发送消息，成功则提交事务channel.txCommit。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs txt">// 开启事务<br> <br>channel.txSelect;<br> <br>try &#123;<br> <br>  // 这里发送消息<br> <br>&#125; catch (Exception e) &#123;<br> <br> channel.txRollback<br> <br> <br> // 这里再次重发这条消息<br> <br>&#125;<br> <br>// 提交事务<br> <br>channel.txCommit;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;但是注意，使用事务的方式非常消耗性能，大大降低 RabbitMQ 的效率，慎用！！！</p><h3 id="方式二：confirm通知"><a href="#方式二：confirm通知" class="headerlink" title="方式二：confirm通知"></a>方式二：confirm通知</h3><p>&amp;emsp;&amp;emsp;RabbitMQ可以在生产者那里将信道设置开启confirm通知模式，每次产出的消息都会分配一个唯一的 id (从1开始)，如果消息成功写入 RabbitMQ 投递到匹配队列，则给生产者回传一个包含唯一id的确认 (Basic.Ack) 给生产者。</p><p>&amp;emsp;&amp;emsp;如果接收失败生产者则重发消息，或者设置超过一定时间没有得到消息回调也可以重发。 </p><p>&amp;emsp;&amp;emsp;如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。 </p><p>&amp;emsp;&amp;emsp;RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 也可以设置 channel.basicAck 方法中的 multiple 参数，表示到这个序号之前的所有消息都已经得到了处理，注意辨别这里的确认和消费时候的确认之间的异同。</p><p><strong>注意：</strong></p><ul><li><p>事务机制和 publisher confirm 机制两者是互斥的，不能共存。</p></li><li><p>事务机制和 publisher confirm 机制确保的是消息能够正确地发送至 RabbitMQ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。</p></li></ul><h2 id="二、RabbitMQ丢失消息"><a href="#二、RabbitMQ丢失消息" class="headerlink" title="二、RabbitMQ丢失消息"></a>二、RabbitMQ丢失消息</h2><p>&amp;emsp;&amp;emsp;原因：RabbitMQ 接收到消息之后，当时是存在内存中的还未消费，此时 RabbitMQ 挂了，再次启动时，内存中的消息丢失。</p><h3 id="开启RabbitMQ持久化"><a href="#开启RabbitMQ持久化" class="headerlink" title="开启RabbitMQ持久化"></a>开启RabbitMQ持久化</h3><p>&amp;emsp;&amp;emsp;当RabbitMQ接收到消息后，将消息持久化到磁盘，此时哪怕 RabbitMQ 挂了，重启之后消息也是还在的。</p><p>&amp;emsp;&amp;emsp;也可以联合之前设置的confirm通知，只有当 RabbitMQ 将消息持久化到磁盘才会回调返回 ack 消息，此时就算如果没持久化到磁盘就丢失了，生产者也会重发消息。</p><p><strong>配置持久化：</strong></p><p>&amp;emsp;&amp;emsp;一、创建queue的时候将其设置为持久化，这样就可以保证RabbitMQ 持久化queue的元数据，但不会保存queue里面的数据。</p><p>&amp;emsp;&amp;emsp;二、将发送消息的 deliveryMode 设置为2，把消息设置为持久化，此时 RabbitMQ 就会把消息持久化到磁盘。</p><p>&amp;emsp;&amp;emsp;并且注意要同时设置这两个持久化才会起作用！！</p><h2 id="三、消费者丢失消息"><a href="#三、消费者丢失消息" class="headerlink" title="三、消费者丢失消息"></a>三、消费者丢失消息</h2><p>&amp;emsp;&amp;emsp;原因：RabbitMQ 的 ack 自动消息确认机制，当 autoAck &#x3D; true 的时候，RabbitMQ 会自动把发送出去的消息设置为确认，然后从内存或磁盘中删除，而不管消费者是否真正的接收到了消息，此时消费者宕机，所以导致消息丢失。</p><h3 id="配置autoAck-x3D-false"><a href="#配置autoAck-x3D-false" class="headerlink" title="配置autoAck &#x3D; false"></a>配置autoAck &#x3D; false</h3><p>&amp;emsp;&amp;emsp;将autoAck设置为false之后，消费者有足够时间处理消息，不用担心消费者未处理完成就宕机的问题，RabbitMQ 会一直等待消费者显示回调 Basic.Ack 命令。</p><p>&amp;emsp;&amp;emsp;并且可以通过 RabbitMQ 的WEB平台上查看消息参数，来监控查看消息的消费情况。</p><h1 id="防止重复消费"><a href="#防止重复消费" class="headerlink" title="防止重复消费"></a>防止重复消费</h1><p>&amp;emsp;&amp;emsp;正常情况下，当消费者处理完消息之后会给消息队列发送确认通知到队列，队列收到后将消息从队列删除。但有时候网络传输故障，导致队列不知道消息已被处理，这个时候队列会将消息再次重复发送到另一个消费者，这个时候就出现消息重复消费的情况了。</p><h3 id="解决：保证消息的作用的唯一性"><a href="#解决：保证消息的作用的唯一性" class="headerlink" title="解决：保证消息的作用的唯一性"></a>解决：保证消息的作用的唯一性</h3><ol><li>做redis的set的操作，不用解决，因为无论set几次结果都是一样的，set操作本来就算幂等操作。</li><li>做数据库的insert操作，可以给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</li><li>最终情况：可以准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ消息丢失&quot;&gt;&lt;a href=&quot;#RabbitMQ消息丢失&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消息丢失&quot;&gt;&lt;/a&gt;RabbitMQ消息丢失&lt;/h1&gt;&lt;p&gt;消息从生产到消费经过三个环节： 生产–&amp;gt;MQ Brok</summary>
      
    
    
    
    
    <category term="RabbitMQ" scheme="http://121.43.167.55/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存异常：穿透、雪崩、击穿</title>
    <link href="http://121.43.167.55/2022/032530555.html"/>
    <id>http://121.43.167.55/2022/032530555.html</id>
    <published>2022-03-25T08:15:00.000Z</published>
    <updated>2022-07-14T12:26:47.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis缓存异常"><a href="#Redis缓存异常" class="headerlink" title="Redis缓存异常"></a>Redis缓存异常</h1><h2 id="一、缓存雪崩"><a href="#一、缓存雪崩" class="headerlink" title="一、缓存雪崩"></a>一、缓存雪崩</h2><p>&amp;emsp;&amp;emsp;缓存雪崩是指缓存的 key 在同一时间大面积的失效，所以后面的请求都会落到数据库上面，造成数据库在短时间内承受大量请求而宕机。</p><p>解决方案：</p><ul><li><p>缓存数据的过期时间设置随机，防止同一时间大量数据同时过期现象发生。</p></li><li><p>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p></li><li><p>给每一个缓存数据增加响应的缓存标记，记录缓存是否失效，如果缓存标记失效则更新数据缓存。</p></li></ul><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p>&amp;emsp;&amp;emsp;缓存穿透是指用户请求缓存和数据库中都没有的数据，导致请求落在数据库上，造成数据短时间内承受大量请求而宕机。</p><p>解决方案：</p><ul><li>可以在缓存中增加一个 key-null 值，用户请求时直接返回一个null值。缓存的有效时间可以设置短一点，设置太长可能导致正常情况也无法使用。</li><li>可以采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</li></ul><h2 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h2><p>&amp;emsp;&amp;emsp;缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞，数据库瞬间压力过大宕机。</p><p>解决方案：</p><ul><li><p>如果这个 key 被经常访问说明这是个热点  key ，可以设置这个热点 key 永不过期。</p></li><li><p>加互斥锁，使用 mutex 。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作，比如 Redis 的 SETNX 去set一个mutex key，当操作返回成功时，再进行 load db 的操作并回设缓存；</p><p>也就是对缓存查询加锁，如果KEY不存在，就加锁，然后查数据库入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据。</p></li></ul><h2 id="四、缓存预热"><a href="#四、缓存预热" class="headerlink" title="四、缓存预热"></a>四、缓存预热</h2><p>&amp;emsp;&amp;emsp;缓存预热是指系统上限之后，将相关的缓存数据直接加载到缓存当中，这样可以避免在用户请求的时候直接查询数据库，这样用户直接请求到已被加载到缓存中数据。</p><p>解决方案：</p><ul><li>直接写个缓存刷新页面，上线前手工操作。</li><li>相关的数据量不大的时候，可以在项目启动时自动加载。</li><li>定时刷新缓存。</li></ul><h2 id="五、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#五、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="五、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>五、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>使用keys指令可以扫出指定模式的key列表。</p><p>但因为是单线程的，如果这个redis正在给线上的业务提供服务，那使用keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p><p>这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis缓存异常&quot;&gt;&lt;a href=&quot;#Redis缓存异常&quot; class=&quot;headerlink&quot; title=&quot;Redis缓存异常&quot;&gt;&lt;/a&gt;Redis缓存异常&lt;/h1&gt;&lt;h2 id=&quot;一、缓存雪崩&quot;&gt;&lt;a href=&quot;#一、缓存雪崩&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://121.43.167.55/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis非关系型数据库</title>
    <link href="http://121.43.167.55/2022/032430455.html"/>
    <id>http://121.43.167.55/2022/032430455.html</id>
    <published>2022-03-24T04:15:42.000Z</published>
    <updated>2022-07-14T12:26:30.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>&amp;emsp;&amp;emsp;Redis是一个使用C语言编写的、开源的高性能非关系型NoSQL键值对数据库。</p><p>&amp;emsp;&amp;emsp;Redis 可以存储键和五种不同类型的值之间的映射，键的类型只能为字符串String，值支持五种数据类型：String字符串、List列表、Set集合、Hash散列表、ZSet有序集合。</p><p>&amp;emsp;&amp;emsp;与传统数据库不同，Redis的数据是存在内存中，所以读写速度非常快，因此被广泛用于缓存方向，每秒可以处理超过10万次读写操作，另外Redis 也经常用来做分布式锁。</p><h2 id="1、Redis优缺点"><a href="#1、Redis优缺点" class="headerlink" title="1、Redis优缺点"></a>1、Redis优缺点</h2><p>优点：</p><ul><li>读写性能优异，Redis读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</li><li>支持数据持久化、支持AOF和RDB两种持久化方式。</li><li>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</li><li>数据结构丰富，除了支持String类型的Value外还支持hash、set、zset、list等数据结构。</li><li>支持主从复制、主机会自动将数据同步到从机，可以支持读写分离。</li></ul><p>缺点：</p><ul><li><p>数据库容量收到物理内存的限制，不能用作海量数据的高性能读写。</p></li><li><p>Redis 不具备自动容错和回复功能，主机从机的宕机会导致前端读写部分失败。</p></li><li><p>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂，后期运维较为麻烦。</p></li></ul><h2 id="2、持久化"><a href="#2、持久化" class="headerlink" title="2、持久化"></a>2、持久化</h2><p>&amp;emsp;&amp;emsp;持久化：将内存中的数据持久化到磁盘当中，防止服务器宕机了内存数据丢失。</p><p>&amp;emsp;&amp;emsp;持久化机制：RDB (默认)、AOF</p><h3 id="RDB-快照持久化-默认"><a href="#RDB-快照持久化-默认" class="headerlink" title="RDB 快照持久化 (默认)"></a>RDB 快照持久化 (默认)</h3><p>&amp;emsp;&amp;emsp;RDB是Redis默认的数据持久化方式，按照一定的时间将内存的数据以快照的形式保存到硬盘当中，产生的数据文件为 dump.rdb。可以通过配置文件中的save参数来定义快照的周期。</p><p>优点：</p><ul><li>只有一个文件dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，可以fork一个子进程来完成写操作，让主进程继续处理指令，保证了Redis的高性能。</li><li>相对于数据集比较大时，比AOF的启动回复效率要高。</li></ul><p>缺点：</p><ul><li>数据安全性低，RDB是间隔一段时间进行持久化，如果持久化间隔时间中Redis发生故障，会发生数据丢失，所以更适合保存不是很严谨的数据。</li></ul><h3 id="AOF-指令持久化"><a href="#AOF-指令持久化" class="headerlink" title="AOF 指令持久化"></a>AOF 指令持久化</h3><p>&amp;emsp;&amp;emsp;AOF： 将Redis执行的每次写操作指令以Redis命令单独记录到日志文件为 .aof文件，当重启Redis会重新将持久化的日志文件中回复数据。</p><p>&amp;emsp;&amp;emsp;当两种方式同时开启时，数据回复会优先选择 AOF方式。</p><p>优点：</p><ul><li>数据安全，AOF持久化可以配置appendfsync属性，没进行一次写操作就记录到aof文件中一次。</li><li>通过append模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF机制的rewrite模式：文件过大时会对命名进行合并重写，当aof文件没被rewrite之前，可以删除其中的某些误操作的命名。</li></ul><p>缺点：</p><ul><li>AOF 文件比RDB文件大，且回复速度慢。</li><li>数据集较大的时候，比RDB启动回复效率低。</li></ul><p>&amp;emsp;&amp;emsp;<strong>一般来说，最好同时使用两种持久化方式，会优先载入AOF文件回复原始数据，通常情况下AOF保存的数据要比RDB完整一些。</strong></p><p><strong>&amp;emsp;&amp;emsp;如果对数据要去不是很严谨，可以承受部分数据的丢失，那么就可以支持RDB。</strong></p><p><strong>&amp;emsp;&amp;emsp;如果只支持AOF持久化，也不推荐，因为定时生成RDB快照非常便于进行数据库备份，而且RDB回复数据速度要快。</strong></p><h2 id="3、主从架构"><a href="#3、主从架构" class="headerlink" title="3、主从架构"></a>3、主从架构</h2><p>&amp;emsp;&amp;emsp;主从架构 (master-slave)，一主多从，主负责写操作，并且将数据复制到其他的Slave节点，从节点负责读操作，所有的读请求全部走从节点，这样也可以很轻松实现水平扩容，支撑读高并发。</p><p>&amp;emsp;&amp;emsp;redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><p><img src="/../img/bg1/posts/Redis%E4%B8%BB%E4%BB%8E.png"></p><h3 id="Redis-replication机制"><a href="#Redis-replication机制" class="headerlink" title="Redis replication机制"></a>Redis replication机制</h3><ul><li>Redis 采用异步方式复制数据到Slave节点，从2.8开始Slave node会周期性地确认自己每次复制的数据量。</li><li>一个Master node是可以配置多个Slave node的。</li><li>Slave node也可以连接其他Slave node。</li><li>Slave node在复制的时候，不会阻塞Master node的工作。</li><li>Slave node在复制的时候，也不会阻塞自己的查询操作，它会用旧的数据集来提供服务，但是当复制完成需要删除旧的数据集，加载新数据集的时候会暂停对外的服务。</li></ul><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>&amp;emsp;&amp;emsp;当启动一个 slave node 的时候，它会发送一个 PSYNC 命令给 master node。</p><p>&amp;emsp;&amp;emsp;如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，</p><p>&amp;emsp;&amp;emsp;同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，</p><p>&amp;emsp;&amp;emsp;接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。</p><p>&amp;emsp;&amp;emsp;slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><img src="/../img/bg1/posts/Redis%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86.png"></p><ul><li>当从库和主库建立MS关系后，会向主数据库发送SYNC命令</li><li>主库接收到SYNC命令后会开始在后台保存快照(RDB持久化过程)，并将期间接收到的写命令缓存起来</li><li>当快照完成后，主Redis会将快照文件和所有缓存的写命令发送给从Redis</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存的命令</li><li>之后，主Redis每当接收到写命令时就会将命令发送从Redis，从而保证数据的一致</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>&amp;emsp;&amp;emsp;所有的Slave节点的复制和同步都是由Master节点来处理，会造成Master节点的压力太大。</p><h2 id="4、哨兵模式"><a href="#4、哨兵模式" class="headerlink" title="4、哨兵模式"></a>4、哨兵模式</h2><p>哨兵：Sentinel，是Redis集群架构中非常重要的一个组件。</p><ul><li><p>集群监控：负责监控Redis Master和Slave进程是否正常工作。</p></li><li><p>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息给系统管理员。</p></li><li><p>故障转移：如果某个Master node挂掉了，会自动通过分布选举机制判定，并转移到Slave node</p></li><li><p>配置中心：如果故障转移发生了，会通知Client客户端新的Master地址。</p><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/Redis%E5%93%A8%E5%85%B5.png"></p></li></ul><p> 哨兵用于实现集群模式的高可用，本身也是分布式的，作为一个哨兵集群去运行，相互协同工作。 </p><ul><li>故障转移时，判断一个Master node是否宕机了，需要大部分的哨兵同意才行，涉及到了选举机制的问题。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制的重要组成部分的故障转移系统本身还是一个单点的，那就非常坑了。</li></ul><p>&amp;emsp;&amp;emsp;<strong>哨兵至少需要三个实例，才能保持本身的健壮性。</strong></p><p><strong>&amp;emsp;&amp;emsp;哨兵+主从部署架构，是不保存数据百分百不丢失的，只能保证Redis集群的高可用性。</strong></p><p><strong>&amp;emsp;&amp;emsp;对于哨兵+主从部署架构，需要在测试环境和生产环境中充分的进行测试。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;Redis是一个使用C语言编写的、开源的高性能非关系型NoSQL键值对数据库</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://121.43.167.55/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot自动配置与运行原理</title>
    <link href="http://121.43.167.55/2022/032237308.html"/>
    <id>http://121.43.167.55/2022/032237308.html</id>
    <published>2022-03-22T10:50:43.000Z</published>
    <updated>2022-07-14T12:26:06.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、springboot自动配置"><a href="#一、springboot自动配置" class="headerlink" title="一、springboot自动配置"></a>一、springboot自动配置</h1><h2 id="1-启动器"><a href="#1-启动器" class="headerlink" title="1.启动器"></a>1.启动器</h2><p>springboot将各种开发功能的环境抽取出来做成了单独的starter(启动器)，开发时只需要在pom.xml中引入启动器，就可以将相关的依赖环境导入进来，所以在使用时做什么功能就引入对应的启动器就可以了。</p><p><strong>启动器： spring-boot-starter</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>springboot将依赖的版本用父项目进行管理，在导入依赖时默认不需要指明版本，除非使用的依赖没有在父项目中。</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是在这里我们并没有看见版本的管理，这里主要是对项目资源过滤以及插件进行管理，在spring-boot-starter-parent点进去可以发现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还有这样一个父依赖，这里才是真正进行版本管理的基地所在。</p><h2 id="2-启动类"><a href="#2-启动类" class="headerlink" title="2.启动类"></a>2.启动类</h2><p>启动类是程序启动的入口，包括了tomcat等服务的启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看上去简简单单，普普通通，只有几行，但是其中的流程是比较复杂的。</p><p><strong>①、@SpringBootApplication：标注了这个类是springboot的主配置类，并且说明这是一个springboot应用，通过运行它标注的main方法来启动应用，如果没有它程序无法启动。</strong></p><p>源码分析：进去之后可以发现在它上面还有注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//四个元注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-comment">//springboot配置类</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-comment">//自动配置</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-comment">//自动扫描，当前包及其子包，</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = EnableAutoConfiguration.class</span><br><span class="hljs-meta">    )</span><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@SpringBootConfiguration：标注当前类为springboot配置类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">//配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = Configuration.class</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyBeanMethods</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>进去之后发现有**@Configuration**，说明这是一个配置类相当于之前的java配置代替xml配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Configuration &#123;<br>    <span class="hljs-meta">@AliasFor(</span><br><span class="hljs-meta">        annotation = Component.class</span><br><span class="hljs-meta">    )</span><br></code></pre></td></tr></table></figure><p>继续进去查看，**@Component**一个非常熟悉的注解，说明这个启动类本身也是被spring容器所管理，是其中的一个负责启动的组件。</p><p><strong>②、@EnableAutoConfiguration：在启动类中这个注解，负责开启自动配置，解放双手。</strong></p><p>在之前需要我们在xml或者java中配置的相关组件，springboot可以实现自动配置。</p><p>继续深入挖掘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自动配置包</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-comment">//给容器导入组件</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@AutoConfigurationPackage：实现自动配置包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>    String[] basePackages() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    Class&lt;?&gt;[] basePackageClasses() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Import({Registrar.class})：在spring容器中导入组件。</p><p>Registrar.class：把启动类所在包及其子包的所有组件进行扫描，并导入。</p><p>回到上一步：</p><p><strong>@Import({AutoConfigurationImportSelector.class})</strong></p><p><strong>AutoConfigurationImportSelector：自动配置导入选择器</strong></p><p>源码追溯：</p><p>第一：getCandidateConfigurations()方法，获取候选的配置组件。</p><p>并且getSpringFactoriesLoaderFactoryClass() 返回了之前看的启动自动导入配置文件的注解类；EnableAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;<br>    List&lt;String&gt; configurations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(SpringFactoriesLoader.loadFactoryNames(<span class="hljs-built_in">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="hljs-built_in">this</span>.getBeanClassLoader()));<br>    ImportCandidates.load(AutoConfiguration.class, <span class="hljs-built_in">this</span>.getBeanClassLoader()).forEach(configurations::add);<br>    Assert.notEmpty(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurations;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二：可以看到调用了SpringFactoriesLoader.loadFactoryNames()方法，点进去看到调用了loadSpringFactories()方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> classLoader;<br>    <span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-literal">null</span>) &#123;<br>        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> factoryType.getName();<br>    <span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure><p>第三：进去loadSpringFactories()方法，注意三个地方：</p><p>1.cache.get(classLoader)：获得classLoader 这里返回EnableAutoConfiguration标注的类本身。</p><p>2.classLoader.getResources(FACTORIES_RESOURCE_LOCATION)：这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： <em>META-INF&#x2F;spring.factories</em> 。</p><p>3.while (urls.hasMoreElements()) {}： 资源遍历并封装成为一个Properties</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>    Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);<br>    <span class="hljs-comment">// 获得classLoader 这里返回EnableAutoConfiguration标注的类本身</span><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);<br>        <span class="hljs-comment">// 这里的FACTORIES_RESOURCE_LOCATION进去后是获取一个资源对象： *META-INF/spring.factories* 。</span><br>        <span class="hljs-comment">// 资源遍历并封装成为一个Properties</span><br>        <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();<br>            <span class="hljs-type">UrlResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> PropertiesLoaderUtils.loadProperties(resource);<br>            <span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> ((String) entry.getKey()).trim();<br>                String[] factoryImplementationNames =<br>                    StringUtils.commaDelimitedListToStringArray((String) entry.getValue());<br>                <span class="hljs-keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;<br>                    result.computeIfAbsent(factoryTypeName, key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())<br>                        .add(factoryImplementationName.trim());<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>第四：查看一下刚刚看到的那个资源文件对象META-INF&#x2F;spring.factories，</p><p>可以发现有很多的配置文件</p><p><img src="/..%5Cimg%5C1654863482713.png" alt="1654863482713"></p><p>随便找一个配置<strong>OnWebApplicationCondition</strong></p><p>自动配置真正实现是从classpath中搜寻所有的META-INF&#x2F;spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、springboot自动配置&quot;&gt;&lt;a href=&quot;#一、springboot自动配置&quot; class=&quot;headerlink&quot; title=&quot;一、springboot自动配置&quot;&gt;&lt;/a&gt;一、springboot自动配置&lt;/h1&gt;&lt;h2 id=&quot;1-启动器&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="spring" scheme="http://121.43.167.55/tags/spring/"/>
    
    <category term="springboot" scheme="http://121.43.167.55/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Spring_IOC操作bean(基于注解)</title>
    <link href="http://121.43.167.55/2022/032030651.html"/>
    <id>http://121.43.167.55/2022/032030651.html</id>
    <published>2022-03-20T01:47:54.000Z</published>
    <updated>2022-07-14T12:25:48.650Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Spring-IOC操作bean管理（基于注解）"><a href="#Spring-IOC操作bean管理（基于注解）" class="headerlink" title="Spring_IOC操作bean管理（基于注解）"></a>Spring_IOC操作bean管理（基于注解）</h1><ul><li><p>格式：@注解名称（属性名&#x3D;属性值，属性名&#x3D;属性值，……）</p></li><li><p>注解可以作用在类，属性，方法。</p></li><li><p>使用注解的目的：简化xml配置</p></li></ul><h2 id="1、基于注解创建对象："><a href="#1、基于注解创建对象：" class="headerlink" title="1、基于注解创建对象："></a>1、基于注解创建对象：</h2><p>spring提供了四种创建对象的注解：</p><ul><li>@Component 全局都可以使用</li><li>@Service：一般用于Service层</li><li>@Controller：一般用于web层</li><li>@ Repository：一般用于Dao层</li></ul><p>这四个注解作用一样，只能注解在类上面，都可以创建对象，但分类后可读性更强。</p><h3 id="第一步：引入依赖包："><a href="#第一步：引入依赖包：" class="headerlink" title="第一步：引入依赖包："></a>第一步：引入依赖包：</h3><p>使用注解方式，有用到AOP编程，所以需要导入AOP依赖包</p><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/20220421110852.png"></p><h3 id="第二步：引入约束文件，并开启组件扫描："><a href="#第二步：引入约束文件，并开启组件扫描：" class="headerlink" title="第二步：引入约束文件，并开启组件扫描："></a>第二步：引入约束文件，并开启组件扫描：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--component-scan是组件扫描属性，base-package指定扫描那个包，被扫描的包下所有使用注解的类及属性都归Spring管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="第三步：在com-dyh-demo-pojo包下创建类并加上注解"><a href="#第三步：在com-dyh-demo-pojo包下创建类并加上注解" class="headerlink" title="第三步：在com.dyh.demo.pojo包下创建类并加上注解"></a>第三步：在com.dyh.demo.pojo包下创建类并加上注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这里通过<span class="hljs-doctag">@Component</span>注解来创建对象,括号中value的值等同于之前xml创建对象使用的id,为了后面使用时通过id来获取对象</span><br><span class="hljs-comment"> * 括号中的内容也可以省略,默认是类名并且首字母小写</span><br><span class="hljs-comment"> * 可以用其他三个注解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br></code></pre></td></tr></table></figure><h3 id="第四步：getBean-获取对象："><a href="#第四步：getBean-获取对象：" class="headerlink" title="第四步：getBean()获取对象："></a>第四步：getBean()获取对象：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;Beans.xml&quot;</span>);<br>        <span class="hljs-comment">// 注意：Bean的id名默认会首字母小写，所以在这里getBean的时候注意id名首字母小写</span><br>        <span class="hljs-type">student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;student&quot;</span>,student.class);<br>        System.out.println(student);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组件扫描的细节配置："><a href="#组件扫描的细节配置：" class="headerlink" title="组件扫描的细节配置："></a>组件扫描的细节配置：</h3><p>&amp;emsp;&amp;emsp;① use-default-fileters属性设置为false表示不使用默认过滤器，通过子标签include-filter来设置只扫描com.oymn包下的所有@Controller修饰的类 。</p><p>&amp;emsp;&amp;emsp;<strong>注意use-default-filters 属性的默认值为 true</strong>，<strong>使用默认的 Filter 进行包扫描</strong>，<strong>默认的 Filter 对标有 @Component,@Service,@Controller和@Repository 的注解的类进行扫描</strong>  。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.oymn&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span>      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;②子标签exclude-filter设置哪些注解不被扫描，例子中为@Controller修饰的类不被扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.oymn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span>           <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;在使用 use-default-filters 属性时要分清楚需要扫描哪些包，是不是需要使用默认的 Filter 进行扫描。即 <strong>use-default-filters&#x3D;”false”</strong> 需要和 <strong>context:include-filter 一起使用</strong>，<strong>不能和 context:exclude-filter 属性一起使用。</strong> </p><h2 id="2、基于注解进行属性注入："><a href="#2、基于注解进行属性注入：" class="headerlink" title="2、基于注解进行属性注入："></a>2、基于注解进行属性注入：</h2><p><strong>@Autowired</strong>：根据属性类型自动装配，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Spring-IOC操作bean管理（基于注解）&quot;&gt;&lt;a href=&quot;#Spring-IOC操作bean管理（基于注解）&quot; class=&quot;headerlink&quot; title=&quot;Spring_IOC操作bean管理（基于注解）&quot;&gt;&lt;/a&gt;S</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://121.43.167.55/tags/Spring/"/>
    
    <category term="框架" scheme="http://121.43.167.55/tags/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="注解" scheme="http://121.43.167.55/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>优秀的Spring框架</title>
    <link href="http://121.43.167.55/2022/031646595.html"/>
    <id>http://121.43.167.55/2022/031646595.html</id>
    <published>2022-03-16T01:40:54.000Z</published>
    <updated>2022-07-14T12:25:17.775Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一、Spring框架概述"><a href="#一、Spring框架概述" class="headerlink" title="一、Spring框架概述"></a>一、Spring框架概述</h1><p>Spring 是轻量级的开源的 JavaEE 框架。</p><p>Spring 可以解决企业应用开发的复杂</p><p>Spring 有两个核心部分：<strong>IOC 和 Aop</strong></p><p>（1）IOC：控制反转，把创建对象过程交给 Spring 进行管理</p><p>（2）Aop：面向切面，不修改源代 码进行功能增强</p><p><strong>Spring 特点 ：</strong></p><p>（1）方便解耦，简化开发</p><p>（2）Aop 编程支持</p><p>（3）方便程序测试</p><p>（4）方便和其他框架进行整合</p><p>（5）方便进行事务操作</p><p>（6）降低 API 开发难度</p><h1 id="二、IOC容器"><a href="#二、IOC容器" class="headerlink" title="二、IOC容器"></a>二、IOC容器</h1><h2 id="1、IOC容器概念"><a href="#1、IOC容器概念" class="headerlink" title="1、IOC容器概念"></a>1、IOC容器概念</h2><ul><li>IOC：控制反转，把对象创建和对象的调用过程交给Spring进行管理。</li><li>目的：<strong>降低耦合度</strong>。</li><li>底层原理：XML，反射，工厂模式。</li><li>Spring提供IOC容器的两种方式(<strong>两个接口</strong>)：</li></ul><p>&amp;emsp;&amp;emsp;<strong>BeanFactory：Spring内部使用的接口，不提倡开发人员使用。</strong></p><p>&amp;emsp;&amp;emsp;&amp;emsp;特点：加载配置文件时不会创建对象，只有在获取对象（getBean()）时才会把配置文件里的对象进行创建。实现类：xmlBeanFactory。</p><p>&amp;emsp;&amp;emsp;<strong>ApplicationContext：BeanFactory的子接口，提供了更多更强大的功能，一般由开发人员使用。</strong></p><p>&amp;emsp;&amp;emsp;&amp;emsp;特点：加载配置文件时就将bean创建为对象。实现类：FileSystemApplicationContext(绝对路径)、ClassPathXmlApplicationContext(相对路径，src开始)。</p><h2 id="2、IOC操作Bean管理-基于XML"><a href="#2、IOC操作Bean管理-基于XML" class="headerlink" title="2、IOC操作Bean管理(基于XML)"></a>2、IOC操作Bean管理(基于XML)</h2><p><strong>Bean管理是指两个操作：Spring创建对象 和 Spring注入属性</strong></p><p><strong>Bean管理有两种操作方式：基于xml配置文件方式实现 和 基于注解方式实现</strong></p><h3 id="（1）基于Xml方式创建对象"><a href="#（1）基于Xml方式创建对象" class="headerlink" title="（1）基于Xml方式创建对象"></a>（1）基于Xml方式创建对象</h3><ul><li>在Spring配置文件中使用bean标签来创建对象</li><li>bean标签有很多属性，常用属性：<ul><li>id：唯一标识</li><li>class：类路径</li></ul></li><li><strong>创建对象时，默认执行无参构造函数</strong></li></ul><h3 id="（2）基于Xml方式注入属性"><a href="#（2）基于Xml方式注入属性" class="headerlink" title="（2）基于Xml方式注入属性"></a>（2）基于Xml方式注入属性</h3><h4 id="第一种：使用Set方法注入："><a href="#第一种：使用Set方法注入：" class="headerlink" title="第一种：使用Set方法注入："></a>第一种：使用Set方法注入：</h4><p>注意该类要先提供Set()方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入属性简易值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;Beans.xml&quot;</span>);<br>        <span class="hljs-type">student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;Student&quot;</span>,student.class);<br>        System.out.println(student);<br></code></pre></td></tr></table></figure><h4 id="第二种：采用有参构造注入："><a href="#第二种：采用有参构造注入：" class="headerlink" title="第二种：采用有参构造注入："></a>第二种：采用有参构造注入：</h4><p>提供构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br></code></pre></td></tr></table></figure><p> xml配置文件中通过constructor-arg标签进行属性注入 ，其中的标签属性name的值是构造方法中参数列表的形参，并且必须所有形参都要值，否则编译报错。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第三种：接口注入（了解即可）："><a href="#第三种：接口注入（了解即可）：" class="headerlink" title="第三种：接口注入（了解即可）："></a>第三种：接口注入（了解即可）：</h4><p>&amp;emsp;&amp;emsp;这里的接口并不是指的java中定义方法的interface接口，而是广义上的资源服务接口，对接的是某处资源的门户，可以通过此门户访问其资源。但是这种用接口注入依赖的方法比较复杂繁琐不方便，在实际开发过程中很少使用。</p><p>&amp;emsp;&amp;emsp;有的时候资源并非来自于自身系统，比如在Tomcat下配置数据库资源，然后通过JNDI的形式去获取它，在Tomcat服务器的context.xml文件中加入自己的一个资源，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span>&gt;</span> <br>    &lt;! --<br>        name 是 JNDI 名称<br>    type 是数据源都要实现的一个接口<br>        url 是数据库的 jdbc 连接<br>        username 用户名<br>        password 数据库密码<br>    --&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc/ssm&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">auth</span>=<span class="hljs-string">&quot;Container&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;javax.sql.DataSource&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">driverClassName</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/ssmzeroDateTimeBehavior=convertToNull&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;root&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;并在WEB工程目录中导入JDBC驱动包，然后使用Spring的机制，用JNDI获取Tomcat启动的数据库连接池，这样就可以在Spring的IOC容器下获取Tomcat所管理的数据库连接池了，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jbdiName&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>java:comp/env/jdbc/ssm<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第四种：命名空间注入（了解即可）"><a href="#第四种：命名空间注入（了解即可）" class="headerlink" title="第四种：命名空间注入（了解即可）"></a>第四种：命名空间注入（了解即可）</h4><p>首先在xml配置文件的约束中引入对应的命名空间和xml模式文件，并在bean标签中操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       </span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:util</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/util&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/util</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注意“c”、”p”、”util”这三行代码，他们定义了xml的命名空间，这样才能在内容中使用p、c、util的前缀定义。</li><li>c命名空间采用构造方法注入,<strong>需要提供有参构造方法</strong>，<strong>c:_0</strong>代表构造方法的第一个参数，<strong>c:_1</strong>代表第二个参数，以此类推。</li><li>p命名空间采用设值(Set方法)注入，<strong>需要提供Set方法</strong>，其中 **p:属性名&#x3D;”属性值”**，其他以此类推。</li><li>util命名空间需要引入XSD约束文件，通过命名空间util定义Map、Set、List集合对象。list-ref代表引用List属性，他的值是上下文定义的bean。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student1&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span> <span class="hljs-attr">c:_0</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">c:_1</span>=<span class="hljs-string">&quot;20&quot;</span><span class="hljs-attr">c:_2-ref</span>=<span class="hljs-string">&quot;list&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student2&quot;</span> </span><br><span class="hljs-tag"><span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;李四&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;Student1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;Student2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span><span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;三&quot;</span><span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span><span class="hljs-attr">p:list-ref</span>=<span class="hljs-string">&quot;list&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="（3）XML注入其他属性"><a href="#（3）XML注入其他属性" class="headerlink" title="（3）XML注入其他属性"></a>（3）XML注入其他属性</h3><h4 id="第一个：null空值"><a href="#第一个：null空值" class="headerlink" title="第一个：null空值"></a>第一个：null空值</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置Student对象--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第二个：属性值中的特殊符号"><a href="#第二个：属性值中的特殊符号" class="headerlink" title="第二个：属性值中的特殊符号"></a>第二个：属性值中的特殊符号</h4><p>&amp;emsp;&amp;emsp;特殊符号是指在xml文件中会被xml解析器解析的符号，比如：&lt; &gt; &#x3D; &amp; 等符号，如果直接在属性值value中声明会报解析错误。需要通过  **&lt;! CDATA [忽略检查的文本]]&gt; ** ,该标签中的内容都会一视同仁的当做纯文本字符数据看待，XMl解析器将其中的内容忽略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>&lt;![CDATA[&lt;尖括号被xml忽略检查&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第三个：注入属性—外部bean"><a href="#第三个：注入属性—外部bean" class="headerlink" title="第三个：注入属性—外部bean"></a>第三个：注入属性—外部bean</h4><p>有两个类：UserService和UserDaoImpl，其中UserDaoImpl实现UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;add&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 ref 来指定创建userDaoImpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDaoImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.UserService&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第四个：注入属性—内部bean"><a href="#第四个：注入属性—内部bean" class="headerlink" title="第四个：注入属性—内部bean"></a>第四个：注入属性—内部bean</h4><p> 不通过ref属性，而是通过嵌套一个bean标签实现 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--内部 bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Emp&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--设置两个普通属性--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lucy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--设置对象类型属性--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Dept&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;人事部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第五个：注入属性—级联赋值"><a href="#第五个：注入属性—级联赋值" class="headerlink" title="第五个：注入属性—级联赋值"></a>第五个：注入属性—级联赋值</h4><p>方法一：也就是上面所说的外部bean，通过ref属性来获取外部bean</p><p>方法二：emp类中有ename和dept两个属性，其中dept有dname属性，写法二需要emp提供dept属性的get方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--级联赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置两个普通属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;lucy&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--写法一--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--写法二--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dept.dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;人事部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;人事部&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="第六个：注入集合-数组属性"><a href="#第六个：注入集合-数组属性" class="headerlink" title="第六个：注入集合 数组属性"></a>第六个：注入集合 数组属性</h4><p>&amp;emsp;&amp;emsp;在集合中注入值，也可以注入对象类型，但是该集合泛型或类型必须是Object类型或对应对象的类型，否则类型不匹配，注入失败。</p><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">private</span> String[] courses;<br>    <span class="hljs-keyword">private</span> List&lt;Object&gt; list;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; map;<br>    <span class="hljs-keyword">private</span> Set&lt;Object&gt; set;<br>    <span class="hljs-keyword">private</span> Properties pro;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPro</span><span class="hljs-params">(Properties pro)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pro = pro;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCourses</span><span class="hljs-params">(String[] courses)</span> &#123;<br>        <span class="hljs-built_in">this</span>.courses = courses;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setList</span><span class="hljs-params">(List&lt;Object&gt; list)</span> &#123;<br>        <span class="hljs-built_in">this</span>.list = list;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map = map;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSet</span><span class="hljs-params">(Set&lt;Object&gt; set)</span> &#123;<br>        <span class="hljs-built_in">this</span>.set = set;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;courses=&quot;</span> + Arrays.toString(courses) +<br>                <span class="hljs-string">&quot;, list=&quot;</span> + list +<br>                <span class="hljs-string">&quot;, map=&quot;</span> + map +<br>                <span class="hljs-string">&quot;, set=&quot;</span> + set +<br>                <span class="hljs-string">&quot;, pro=&quot;</span> + pro +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在xml配置文件中注入值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;courses&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>王五<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>王五<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;student1&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;student2&quot;</span>/&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;王五&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;student1&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">&quot;student2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;set&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>王五<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;student1&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;student2&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pro&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>王五<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;也可以把集合注入部分提取出来，使用util标签，使得不同的bean都可以使用，提高代码复用性与可读性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">util:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;Student&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;Student&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Student2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.student&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span><span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span><span class="hljs-attr">p:list-ref</span>=<span class="hljs-string">&quot;list&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="（4）xml自动装配："><a href="#（4）xml自动装配：" class="headerlink" title="（4）xml自动装配："></a>（4）xml自动装配：</h3><ul><li>根据指定的装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入</li><li>根据属性名称自动装配：要求 emp中属性的名称dept 和 bean标签的id值dept 一样，才能识别</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定autowire属性值为byName--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Emp&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Dept&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>根据属性类型自动装配：要求同一个xml文件中不能有两个相同类型的bean，否则无法识别是哪一个</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定autowire属性值为byType--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Emp&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.demo.pojo.Dept&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="（5）外部properties属性文件操作bean："><a href="#（5）外部properties属性文件操作bean：" class="headerlink" title="（5）外部properties属性文件操作bean："></a>（5）外部properties属性文件操作bean：</h3><p>很多时候资源来自于系统外部，比如配置数据库信息</p><h4 id="①导入Druid连接池jar包："><a href="#①导入Druid连接池jar包：" class="headerlink" title="①导入Druid连接池jar包："></a>①导入Druid连接池jar包：</h4><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/Druid%E8%BF%9E%E6%8E%A5%E6%B1%A0jar%E5%8C%85%E6%88%AA%E5%9B%BE.png"></p><h4 id="②创建外部properties属性文件，配置数据库信息："><a href="#②创建外部properties属性文件，配置数据库信息：" class="headerlink" title="②创建外部properties属性文件，配置数据库信息："></a>②创建外部properties属性文件，配置数据库信息：</h4><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6%E6%88%AA%E5%9B%BE.png"></p><h4 id="③bean配置："><a href="#③bean配置：" class="headerlink" title="③bean配置："></a>③bean配置：</h4><p>引入context名称空间，并通过context标签引入外部属性文件，使用EL表达式“${}”来获取文件中对应的值 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;prop.driverClassName&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;prop.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;prop.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;prop.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3、Bean-的作用域与生命周期"><a href="#3、Bean-的作用域与生命周期" class="headerlink" title="3、Bean 的作用域与生命周期"></a>3、Bean 的作用域与生命周期</h2><h3 id="①、作用域"><a href="#①、作用域" class="headerlink" title="①、作用域"></a>①、作用域</h3><table><thead><tr><th align="left">Scope</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><a href="#beans-factory-scopes-singleton">singleton</a></td><td align="left">Spring默认的选项，单例，每个bean只有在初始化时创建一个对象。</td></tr><tr><td align="left"><a href="#beans-factory-scopes-prototype">prototype</a></td><td align="left">原型，多例，可以手动设置，在getBean()时创建对象。</td></tr><tr><td align="left"><a href="#beans-factory-scopes-request">request</a></td><td align="left">将单个bean作用于单个HTTP请求的生命周期，每个HTTP请求都有自己的bean实例，该实例是在单个bean定义的基础上创建的，仅在web项目的Spring<code>ApplicationContext</code>上下文中有效。</td></tr><tr><td align="left"><a href="#beans-factory-scopes-session">session</a></td><td align="left">将单个bean定义作用于HTTP会话的生命周期，仅在web项目的Spring<code>ApplicationContext</code>上下文中有效。</td></tr><tr><td align="left"><a href="#beans-factory-scopes-application">application</a></td><td align="left">将单个bean定义作用于Servletcontext的生命周期。 仅在web项目的Spring<code>ApplicationContext</code>上下文中有效。</td></tr><tr><td align="left"><a href="web.html#websocket-stomp-websocket-scope">websocket</a></td><td align="left">将单个bean定义作用于WebSocket 的生命周期。仅在web项目的Spring<code>ApplicationContext</code>上下文中有效。</td></tr></tbody></table><p>在Spring中，默认情况下的Bean是单例对象。</p><p>通过bean标签的scopo属性来设置单实例还是多实例。</p><ul><li><p>singleton：默认值，表示单实例对象。加载配置文件时就会创建单实例对象。</p></li><li><p>prototype：表示多实例对象。不是在加载配置文件时创建对象，在调用getBean方法时创建多实例对象。</p></li></ul><h3 id="②、生命周期"><a href="#②、生命周期" class="headerlink" title="②、生命周期"></a>②、生命周期</h3><p>&amp;emsp;&amp;emsp;Spring IoC容器对于管理的bean，在整个bean生命周期内，Spring IoC容器为我们提供了一些生命周期方法（钩子方法），我们可以给出钩子方法的具体实现，然后Spring容器会在相应的时机调用这些钩子方法。</p><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/Spring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>Bean 生命周期的整个执行过程描述如下:</p><ol><li>Spring 启动，查找并加载需要被 Spring 管理的 Bean，对 Bean 进行实例化。</li><li>对 Bean 进行属性注入。</li><li>如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</li><li>如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</li><li>如果 Bean 实现了 BeanPostProcessor 接口，则 Spring 调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</li><li>如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。</li><li>如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</li><li>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</li><li>如果在 <bean> 中指定了该 Bean 的作用域为 singleton，则将该 Bean 放入 Spring IoC 的缓存池中，触发 Spring 对该 Bean 的生命周期管理；如果在 <bean> 中指定了该 Bean 的作用域为 prototype，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该 Bean。</li><li>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法销毁 Bean；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</li></ol><p><strong>代码演示：</strong></p><p>实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dyh.pojo;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.*;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: Person</span><br><span class="hljs-comment"> * Package: com.dyh.pojo</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/4/21 16:17</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: yangzhihong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, BeanFactoryAware, ApplicationContextAware, InitializingBean, DisposableBean &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step1: 调用无参构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step2: 调用了set方法&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义初始化方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myInit</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step8: 自定义初始化方法 myInit&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义销毁方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myDestroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step12: 自定义销毁方法 myDestroy&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step3: 调用了BeanNameAware接口中的setBeanName方法：&quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;step4: 调用BeanFactoryAware接口中setBeanFactory方法：&quot;</span> + beanFactory);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;step5: 调用ApplicationContextAware接口中setApplicationContext方法：&quot;</span> + applicationContext);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;step7: 调用了InitializingBean接口的afterPropertiesSet方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;step10: 成员方法 show方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;step11: 调用了DisposableBean接口的destroy方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义Bean后处理器,也是一个bean，需要被spring容器管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dyh.processor;<br><span class="hljs-keyword">import</span> com.dyh.pojo.Person;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: MyBeanPostProcessor</span><br><span class="hljs-comment"> * Package: com.dyh.processor</span><br><span class="hljs-comment"> * Description: 自定义Bean后处理器,也是一个bean，需要被spring容器管理</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/4/21 16:51</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: yangzhihong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;step6: bean后处理器的前置方法:&quot;</span> + bean);<br><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;step9: bean后处理器的后置方法:&quot;</span> + bean);<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注册bean后处理器 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.processor.MyBeanPostProcessor&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">      bean标签</span><br><span class="hljs-comment">          init-method属性：关联自定义初始化方法</span><br><span class="hljs-comment">          destroy-method属性： 关联自定义销毁方法</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;per&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dyh.pojo.Person&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;myInit&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;myDestroy&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--property标签可以给属性注入初始值</span><br><span class="hljs-comment">          DI注入：给bean指定的属性注入初始值</span><br><span class="hljs-comment">          name属性： 设置属性名称</span><br><span class="hljs-comment">          value属性： 设置属性的基础值，只能设置基本数据类型和String</span><br><span class="hljs-comment">          ref属性： 设置对象类型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          Spring属性注入依赖的是set方法</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张三&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;bean.xml&quot;</span>);<br><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> ac.getBean(Person.class);<br><br>        per.show();<br><br>        <span class="hljs-comment">// ApplicationContext没有关闭方法，但是实现类有</span><br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> (ClassPathXmlApplicationContext) ac;<br>        context.close();<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="自定义Bean的生命周期"><a href="#自定义Bean的生命周期" class="headerlink" title="自定义Bean的生命周期"></a>自定义Bean的生命周期</h4><p>&amp;emsp;&amp;emsp;我们可以在 Spring Bean 生命周期的某个特定时刻，指定一些生命周期回调方法完成一些自定义的操作，对 Bean 的生命周期进行管理。<br>Bean 的生命周期回调方法主要有两种：</p><ul><li>初始化回调方法：在 Spring Bean 被初始化后调用，执行一些自定义的回调操作。</li><li>销毁回调方法：在 Spring Bean 被销毁前调用，执行一些自定义的回调操作。</li></ul><p>我们可以通过以下 3 种方式自定义 Bean 的生命周期回调方法：</p><ul><li>通过接口实现</li><li>通过 XML 配置实现</li><li>使用注解实现</li></ul><p> 如果一个 Bean 中有多种生命周期回调方法时，优先级顺序为：注解 &gt; 接口 &gt; XML 配置。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一、Spring框架概述&quot;&gt;&lt;a href=&quot;#一、Spring框架概述&quot; class=&quot;headerlink&quot; title=&quot;一、Spring框架概述&quot;&gt;&lt;/a&gt;一、Spring框架概述&lt;/h1&gt;&lt;p&gt;Spring 是轻量级的开源的 J</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://121.43.167.55/tags/Spring/"/>
    
    <category term="框架" scheme="http://121.43.167.55/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统概论</title>
    <link href="http://121.43.167.55/2022/031435514.html"/>
    <id>http://121.43.167.55/2022/031435514.html</id>
    <published>2022-03-14T08:41:07.000Z</published>
    <updated>2022-07-14T12:24:57.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据系统系统"><a href="#数据系统系统" class="headerlink" title="数据系统系统"></a>数据系统系统</h1><h2 id="一、第一篇"><a href="#一、第一篇" class="headerlink" title="一、第一篇"></a>一、第一篇</h2><h3 id="1、数据库的四个基本概念"><a href="#1、数据库的四个基本概念" class="headerlink" title="1、数据库的四个基本概念"></a>1、数据库的四个基本概念</h3><p><strong>①、数据：</strong>描述事务的符号记录</p><p><strong>②、数据库：</strong>概括地讲，数据库具有永久储存、有组织、可共享的三个基本特点。</p><p>&amp;emsp;&amp;emsp;严格来说：数据库是长期储存在计算机内、有组织、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享。</p><p><strong>③、数据库管理系统：</strong>是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件。</p><p>主要功能：</p><ul><li>数据定义功能；</li><li>数据组织、存储和管理；</li><li>数据操纵功能；</li><li>数据库的事务管理和运行管理；</li><li>数据库的建立和维护功能；</li><li>其他功能（通信功能、数据转换功能、互访和互操作功能）；</li></ul><p><strong>④、数据库系统：</strong>是由数据库、数据管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理、和维护数据的系统。</p><h2 id="2、用户访问数据库的过程图"><a href="#2、用户访问数据库的过程图" class="headerlink" title="2、用户访问数据库的过程图"></a>2、用户访问数据库的过程图</h2><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/用户-数据库.png" style="zoom: 80%;" /><h2 id="3、数据库的发展历史阶段"><a href="#3、数据库的发展历史阶段" class="headerlink" title="3、数据库的发展历史阶段"></a>3、数据库的发展历史阶段</h2><ul><li>①、人工管理阶段：数据不保存、不共享、不具有独立性。</li><li>③、文件系统管理阶段：可保存但共享性差、冗余度高、独立性差。</li><li>④、数据库管理系统：数据库系统的出现使得信息系统从以  加工数据的程序为中心  转向  共享的数据库为中心  的阶段，实现整体数据的结构化。</li></ul><p>数据的共享性高、冗余度低且易扩充；数据共享可以大大减少数据冗余、节约储存空间。</p><p>数据的独立性高：</p><p>&amp;emsp;&amp;emsp;物理独立性：是指用户的应用程序与数据库的物理存储是相互独立的。</p><p>&amp;emsp;&amp;emsp;逻辑独立性：是指用的应用程序与数据库的逻辑结构是相互独立的。</p><p>数据由数据库管理系统统一管理和控制。</p><h2 id="4、数据模型"><a href="#4、数据模型" class="headerlink" title="4、数据模型"></a>4、数据模型</h2><p>&amp;emsp;&amp;emsp;有两类模型：概念模型+逻辑模型 和 物理模型。</p><p>&amp;emsp;&amp;emsp;人们先将现实世界抽象为信息世界，然后将信息世界转化为机器理解的数据世界。</p><p>①、概念模型：也称为信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。</p><ul><li>实体：客观存在并可相互区别的事物。人</li><li>属性：实体所具有的某一特性。人的鼻子嘴巴</li><li>码：唯一标识实体的属性。学号，在mysql中称为键</li><li>实体型：用实体名及其属性集合来抽象和刻画同类实体。含有嘴巴鼻子的人</li><li>实体集：同一类型实体的集合。学校</li><li>联系：实体之间的联系通常是指不同实体集之间的联系，实体之间的联系有一对一、一对多和多对多等多种联系。</li></ul><p>概念模型的一种表示方法：实体—联系方法。</p><p>用ER图来描述现实世界的概念模型，E-R方法也称为E-R模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据系统系统&quot;&gt;&lt;a href=&quot;#数据系统系统&quot; class=&quot;headerlink&quot; title=&quot;数据系统系统&quot;&gt;&lt;/a&gt;数据系统系统&lt;/h1&gt;&lt;h2 id=&quot;一、第一篇&quot;&gt;&lt;a href=&quot;#一、第一篇&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://121.43.167.55/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于MyBatis_缓存</title>
    <link href="http://121.43.167.55/2022/021232284.html"/>
    <id>http://121.43.167.55/2022/021232284.html</id>
    <published>2022-02-12T07:56:25.000Z</published>
    <updated>2023-01-13T13:39:24.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于MyBatis-缓存"><a href="#关于MyBatis-缓存" class="headerlink" title="关于MyBatis_缓存"></a>关于MyBatis_缓存</h1><h2 id="一、MyBatis缓存简介"><a href="#一、MyBatis缓存简介" class="headerlink" title="一、MyBatis缓存简介"></a>一、MyBatis缓存简介</h2><p>MyBatis是常见的Java数据库访问层框架，MyBatis中允许使用缓存，缓存一般都放置在可高速读&#x2F;写的存储器上，比如服务器的内存，它能够有效提高系统的性能。因为数据库在大部分场景下是把存储在磁盘上的数据索引出来。从硬件的角度分析，索引磁盘是一个较为缓慢的过程，读取内存或者高速缓存处理器的速度要比读取磁盘快得多，其速度是读取硬盘的几十倍到上百倍,但是内存和高速缓存处理器的空间有限，所以一般只会把那些常用且命中率高的数据缓存起来，以便将来使用，而不缓存那些不常用且命中率低的数据缓存。因为命中率低，最后还是要在磁盘内查找,并不能有效提高性能。</p><p>MyBatis分为一级缓存和二级缓存，一级缓存是在SqlSession上的缓存，二级缓存是在SqlSessionFactory上的缓存，同时也可以配置关于缓存的设置。</p><h2 id="二、一级缓存"><a href="#二、一级缓存" class="headerlink" title="二、一级缓存"></a>二、一级缓存</h2><p>在程序运行过程中，我们可能会在一次数据库会话中执行完全相同的SQL语句，如果不停的访问数据库会影响运行效率，MyBatis提供的一级缓存优化了这一场景。</p><p>MyBatis一级缓存的生命周期和SqlSession一致。</p><p>MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上欠缺。</p><p>MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</p><p>如果是相同的SQL语句，会优先命中一级缓存中的数据，而不会去访问数据库，执行过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%981.png"></p><p> 每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成<code>MappedStatement</code>，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入<code>Local Cache</code>，最后返回结果给用户。 </p><h3 id="1、测试：一级缓存有效查询数据库次数"><a href="#1、测试：一级缓存有效查询数据库次数" class="headerlink" title="1、测试：一级缓存有效查询数据库次数"></a>1、测试：一级缓存有效查询数据库次数</h3><p>一级缓存的作用范围是会话级别，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><span class="hljs-comment">//        SqlSession session2 = MybatisUtils.getSqlSession();</span><br><span class="hljs-comment">//        SqlSession session3 = MybatisUtils.getSqlSession();</span><br><br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> session1.getMapper(UserMapper.class);<br><span class="hljs-comment">//            UserMapper mapper2 = session2.getMapper(UserMapper.class);</span><br><span class="hljs-comment">//            ApartMapper mapper3 = session3.getMapper(ApartMapper.class);</span><br><br>            System.out.println(<span class="hljs-string">&quot;第一次读取&quot;</span> + mapper1.findBid(<span class="hljs-number">1</span>));<br>            System.out.println(<span class="hljs-string">&quot;第二次读取&quot;</span> + mapper1.findBid(<span class="hljs-number">1</span>));<br>            System.out.println(<span class="hljs-string">&quot;第三次读取&quot;</span> + mapper1.findBid(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 10:57:13,302 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 10:57:13,332 demo.dao.UserMapper.findBid: ==&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: ====&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.ApartMapper.findByAid: &lt;====      Total: 1<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>第一次读取Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.0<br>第二次读取Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 10:57:13,351 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.0<br>第三次读取Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure><p>只有第一次执行了SQL语句查询数据库，其他两次都是从一级缓存中获取。</p><h3 id="2、测试：在会话中修改数据库是否会对一级缓存造成影响"><a href="#2、测试：在会话中修改数据库是否会对一级缓存造成影响" class="headerlink" title="2、测试：在会话中修改数据库是否会对一级缓存造成影响"></a>2、测试：在会话中修改数据库是否会对一级缓存造成影响</h3><p>我们增加对数据的修改操作，看是否会使得一级缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session3</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ApartMapper</span> <span class="hljs-variable">mapper3</span> <span class="hljs-operator">=</span> session3.getMapper(ApartMapper.class);<br><br>        System.out.println(mapper3.findByAid(<span class="hljs-number">1</span>));<br><br>        System.out.println(mapper3.update(<span class="hljs-string">&quot;物业部&quot;</span>,<span class="hljs-number">1</span>));<br><br>        System.out.println(mapper3.findByAid(<span class="hljs-number">1</span>));<br>        session3.commit();<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 11:04:01,039 demo.dao.ApartMapper.findByAid: ==&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 11:04:01,089 demo.dao.ApartMapper.findByAid: &lt;==      Total: 1<br>Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;<br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.update: ==&gt;  Preparing: update t<span class="hljs-built_in">_</span>dep set dname = ? where did = ? <br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.update: ==&gt; Parameters: 物业部(String), 1(Integer)<br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.update: &lt;==    Updates: 1<br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0<br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.findByAid: ==&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.findByAid: ==&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:04:01,090 demo.dao.ApartMapper.findByAid: &lt;==      Total: 1<br>Apart&#123;did=1, dname=&#x27;物业部&#x27;&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在执行修改操作之后，再次查询了数据库，<strong>一级缓存失效</strong></p><h3 id="3、测试：验证一级缓存作用范围"><a href="#3、测试：验证一级缓存作用范围" class="headerlink" title="3、测试：验证一级缓存作用范围"></a>3、测试：验证一级缓存作用范围</h3><p>开启两个SqlSession，对同一个命名空间进行操作，判断两个对象是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> session1.getMapper(UserMapper.class);<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br><br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp1</span> <span class="hljs-operator">=</span> mapper1.findBid(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;SqlSession1读取：&quot;</span> + emp1);<br><br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp2</span> <span class="hljs-operator">=</span> mapper2.findBid(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;SqlSession2读取：&quot;</span> + emp2);<br><br>        System.out.println(emp1 == emp2);<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 11:21:26,730 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 11:21:26,779 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>SqlSession1读取：Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 11:21:26,781 org.apache.ibatis.transaction.jdbc.JdbcTransaction: <br>DEBUG 2022-04-13 11:21:26,787 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 11:21:26,788 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 11:21:26,789 demo.dao.ApartMapper.findByAid: ====&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:21:26,789 demo.dao.ApartMapper.findByAid: &lt;====      Total: 1<br>DEBUG 2022-04-13 11:21:26,789 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>SqlSession2读取：Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>两个对象不相同false<br></code></pre></td></tr></table></figure><p>可以看到，程序运行后，SQL语句执行了两次，对数据库进行了两次访问操作，最后两个结果对象对比也是为false，证明一级缓存无效，一级缓存只能在SqlSession会话内部共享。</p><h3 id="4、源码分析"><a href="#4、源码分析" class="headerlink" title="4、源码分析"></a>4、源码分析</h3><p><strong>SqlSession</strong>： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是<code>DefaultSqlSession</code>。</p><img src="C:\Users\yang\Desktop\ba96bc7f.jpg" alt="img" style="zoom:50%;" /><p><strong>Executor</strong>： <code>SqlSession</code>向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。</p><img src="C:\Users\yang\Desktop\ef5e0eb3.jpg" alt="img" style="zoom: 50%;" /><p>如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力</p><img src="C:\Users\yang\Desktop\83326eb3.jpg" alt="img" style="zoom:50%;" /><p><strong>BaseExecutor</strong>： <code>BaseExecutor</code>是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doUpdate</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> List&lt;BatchResult&gt; <span class="hljs-title function_">doFlushStatements</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isRollback)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;E&gt; Cursor&lt;E&gt; <span class="hljs-title function_">doQueryCursor</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException;<br></code></pre></td></tr></table></figure><p>在一级缓存的介绍中提到对<code>Local Cache</code>的查询和写入是在<code>Executor</code>内部完成的。在阅读<code>BaseExecutor</code>的代码后发现<code>Local Cache</code>是<code>BaseExecutor</code>内部的一个成员变量，如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br><span class="hljs-keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;<br><span class="hljs-keyword">protected</span> PerpetualCache localCache;<br></code></pre></td></tr></table></figure><p><strong>Cache</strong>： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示：</p><img src="C:\Users\yang\Desktop\793031d0.jpg" alt="img" style="zoom: 80%;" /><p>有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：</p><img src="C:\Users\yang\Desktop\cdb21712.jpg" alt="img" style="zoom: 50%;" /><p><code>BaseExecutor</code>成员变量之一的<code>PerpetualCache</code>，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerpetualCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cache</span> &#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Object, Object&gt;();<br></code></pre></td></tr></table></figure><p>为执行和数据库的交互，首先需要初始化<code>SqlSession</code>，通过<code>DefaultSqlSessionFactory</code>开启<code>SqlSession</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SqlSession <span class="hljs-title function_">openSessionFromDataSource</span><span class="hljs-params">(ExecutorType execType, TransactionIsolationLevel level, <span class="hljs-type">boolean</span> autoCommit)</span> &#123;<br>    ............<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> configuration.newExecutor(tx, execType);     <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);<br>&#125;<br></code></pre></td></tr></table></figure><p>在初始化<code>SqlSesion</code>时，会使用<code>Configuration</code>类创建一个全新的<code>Executor</code>，作为<code>DefaultSqlSession</code>构造函数的参数，创建Executor代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">newExecutor</span><span class="hljs-params">(Transaction transaction, ExecutorType executorType)</span> &#123;<br>    executorType = executorType == <span class="hljs-literal">null</span> ? defaultExecutorType : executorType;<br>    executorType = executorType == <span class="hljs-literal">null</span> ? ExecutorType.SIMPLE : executorType;<br>    Executor executor;<br>    <span class="hljs-keyword">if</span> (ExecutorType.BATCH == executorType) &#123;<br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ExecutorType.REUSE == executorType) &#123;<br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReuseExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleExecutor</span>(<span class="hljs-built_in">this</span>, transaction);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cacheEnabled) &#123;<br>        <span class="hljs-comment">// 二级缓存开启，使用CahingExecutor装饰BaseExecutor的子类</span><br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingExecutor</span>(executor);                      <br>    &#125;<br>    executor = (Executor) interceptorChain.pluginAll(executor);<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SqlSession</code>创建完毕后，根据Statment的不同类型，会进入<code>SqlSession</code>的不同方法中，如果是<code>Select</code>语句的话，最后会执行到<code>SqlSession</code>的<code>selectList</code>，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">selectList</span><span class="hljs-params">(String statement, Object parameter, RowBounds rowBounds)</span> &#123;<br>      <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">ms</span> <span class="hljs-operator">=</span> configuration.getMappedStatement(statement);<br>      <span class="hljs-keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>SqlSession</code>把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入<code>BaseExecutor</code>的<code>query</code>方法。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">BoundSql</span> <span class="hljs-variable">boundSql</span> <span class="hljs-operator">=</span> ms.getBoundSql(parameter);<br>    <span class="hljs-type">CacheKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> createCacheKey(ms, parameter, rowBounds, boundSql);<br>    <span class="hljs-keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheKey</span>();<br>cacheKey.update(ms.getId());<br>cacheKey.update(rowBounds.getOffset());<br>cacheKey.update(rowBounds.getLimit());<br>cacheKey.update(boundSql.getSql());<br>cacheKey.update(value);<br><span class="hljs-comment">//value是update的sql中带的参数</span><br></code></pre></td></tr></table></figure><p>在上述的代码中，将<code>MappedStatement</code>的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_MULTIPLYER</span> <span class="hljs-operator">=</span> <span class="hljs-number">37</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_HASHCODE</span> <span class="hljs-operator">=</span> <span class="hljs-number">17</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> multiplier;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hashcode;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> checksum;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><span class="hljs-keyword">private</span> List&lt;Object&gt; updateList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheKey</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.hashcode = DEFAULT_HASHCODE;<br>    <span class="hljs-built_in">this</span>.multiplier = DEFAULT_MULTIPLYER;<br>    <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">this</span>.updateList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是成员变量和构造函数，有一个初始的<code>hachcode</code>和乘数，同时维护了一个内部的<code>updatelist</code>。在<code>CacheKey</code>的<code>update</code>方法中，会进行一个<code>hashcode</code>和<code>checksum</code>的计算，同时把传入的参数添加进<code>updatelist</code>中。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Object object)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">baseHashCode</span> <span class="hljs-operator">=</span> object == <span class="hljs-literal">null</span> ? <span class="hljs-number">1</span> : ArrayUtil.hashCode(object); <br>    count++;<br>    checksum += baseHashCode;<br>    baseHashCode *= count;<br>    hashcode = multiplier * hashcode + baseHashCode;<br>    <br>    updateList.add(object);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时重写了<code>CacheKey</code>的<code>equals</code>方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span> &#123;<br>    .............<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; updateList.size(); i++) &#123;<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">thisObject</span> <span class="hljs-operator">=</span> updateList.get(i);<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">thatObject</span> <span class="hljs-operator">=</span> cacheKey.updateList.get(i);<br>      <span class="hljs-keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除去hashcode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL。</p><blockquote><p>Statement Id + Offset + Limmit + Sql + Params</p></blockquote><p>BaseExecutor的query方法继续往下走，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">list = resultHandler == <span class="hljs-literal">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 处理存储过程</span><br><span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>    handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果查不到的话，就从数据库查，在<code>queryFromDatabase</code>中，会对<code>localcache</code>进行写入。</p><p>在<code>query</code>方法执行的最后，会判断一级缓存级别是否是<code>STATEMENT</code>级别，如果是的话，就清空缓存，这也就是<code>STATEMENT</code>级别的一级缓存无法共享<code>localCache</code>的原因。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;<br>        clearLocalCache();<br>&#125;<br></code></pre></td></tr></table></figure><p>在源码分析的最后，我们确认一下，如果是<code>insert/delete/update</code>方法，缓存就会刷新的原因。</p><p><code>SqlSession</code>的<code>insert</code>方法和<code>delete</code>方法，都会统一走<code>update</code>的流程，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String statement, Object parameter)</span> &#123;<br>    <span class="hljs-keyword">return</span> update(statement, parameter);<br>  &#125;<br>   <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String statement)</span> &#123;<br>    <span class="hljs-keyword">return</span> update(statement, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>update</code>方法也是委托给了<code>Executor</code>执行。<code>BaseExecutor</code>的执行方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    ErrorContext.instance().resource(ms.getResource()).activity(<span class="hljs-string">&quot;executing an update&quot;</span>).object(ms.getId());<br>    <span class="hljs-keyword">if</span> (closed) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorException</span>(<span class="hljs-string">&quot;Executor was closed.&quot;</span>);<br>    &#125;<br>    clearLocalCache();<br>    <span class="hljs-keyword">return</span> doUpdate(ms, parameter);<br>&#125;<br></code></pre></td></tr></table></figure><p>每次执行<code>update</code>前都会清空<code>localCache</code>。</p><h2 id="三、二级缓存"><a href="#三、二级缓存" class="headerlink" title="三、二级缓存"></a>三、二级缓存</h2><p>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</p><p>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</p><p>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</p><h3 id="1、配置"><a href="#1、配置" class="headerlink" title="1、配置"></a>1、配置</h3><p>在MyBatis主配置文件中开启二级缓存 cacheEnabled，默认为true。</p><p>记得实体类pojo要实现序列化接口，<code>implements Serializable</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在映射器XML文件中声明这个命名空间使用二级缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    参数详解：</span><br><span class="hljs-comment">    type：cache使用的类型，默认是PerpetualCache，这在一级缓存中提到过。</span><br><span class="hljs-comment">    eviction： 定义回收的策略，常见的有FIFO，LRU。</span><br><span class="hljs-comment">    flushInterval： 配置一定时间自动刷新缓存，单位是毫秒。</span><br><span class="hljs-comment">    size： 最多缓存对象的个数。</span><br><span class="hljs-comment">    readOnly： 是否只读，若配置可读写，则需要对应的实体类能够序列化。</span><br><span class="hljs-comment">    blocking： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;mapper.StudentMapper&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--cache-ref代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、测试：当事务操作未提交时，二级缓存是否有效"><a href="#2、测试：当事务操作未提交时，二级缓存是否有效" class="headerlink" title="2、测试：当事务操作未提交时，二级缓存是否有效"></a>2、测试：当事务操作未提交时，二级缓存是否有效</h3><p>开启两个SqlSession，运行但不进行commit()提交操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> session1.getMapper(UserMapper.class);<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br><br>        System.out.println(mapper1.findBid(<span class="hljs-number">1</span>));<br>        System.out.println(mapper2.findBid(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 11:43:03,514 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 11:43:03,545 demo.dao.UserMapper.findBid: ==&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0<br>DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 11:43:03,564 demo.dao.ApartMapper.findByAid: ====&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:43:03,567 demo.dao.ApartMapper.findByAid: &lt;====      Total: 1<br>DEBUG 2022-04-13 11:43:03,567 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br><br>DEBUG 2022-04-13 11:43:03,573 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 11:43:03,573 demo.dao.UserMapper.findBid: ==&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.0<br>DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 11:43:03,575 demo.dao.ApartMapper.findByAid: ====&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 11:43:03,576 demo.dao.ApartMapper.findByAid: &lt;====      Total: 1<br>DEBUG 2022-04-13 11:43:03,576 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure><p>可以看到，执行了两次SQL语句，对数据库进行了两次访问，<strong>证明当不进行commit()提交操作时二级缓存无效，所以请大家注意，在二级缓存中需要commit()提交事务才能生效。</strong></p><h3 id="3、测试：更新数据操作是否刷新所在-namespace-的二级缓存"><a href="#3、测试：更新数据操作是否刷新所在-namespace-的二级缓存" class="headerlink" title="3、测试：更新数据操作是否刷新所在 namespace 的二级缓存"></a>3、测试：更新数据操作是否刷新所在 namespace 的二级缓存</h3><p>创建三个SqlSession，先查询两次，证明二级缓存有效，然后定义修改方法，对表进行更新，测试第三次查询是走数据库还是二级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>     <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>     <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session3</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> session1.getMapper(UserMapper.class);<br>         <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br>         <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper3</span> <span class="hljs-operator">=</span> session3.getMapper(UserMapper.class);<br><br>         System.out.println(<span class="hljs-string">&quot;emp1读取内容：&quot;</span> + mapper1.findBid(<span class="hljs-number">1</span>));<br>         session1.commit();<br>         System.out.println(<span class="hljs-string">&quot;emp2读取内容：&quot;</span> + mapper2.findBid(<span class="hljs-number">1</span>));<br><br>         mapper3.update(<span class="hljs-string">&quot;王麻子&quot;</span>,<span class="hljs-number">1</span>);<br>         session3.commit();<br>         System.out.println(<span class="hljs-string">&quot;emp2读取内容：&quot;</span> + mapper2.findBid(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 12:33:39,919 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 12:33:39,979 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>emp1读取内容：Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.5<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;李四&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: ==&gt;  Preparing: update t<span class="hljs-built_in">_</span>emp set ename = ? where eid = ? <br>DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: ==&gt; Parameters: 王麻子(String), 1(Integer)<br>DEBUG 2022-04-13 12:33:40,040 demo.dao.UserMapper.update: &lt;==    Updates: 1<br>DEBUG 2022-04-13 12:33:40,040 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@2db7a79b]<br>DEBUG 2022-04-13 12:33:40,060 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 12:33:40,060 demo.dao.UserMapper.findBid: ==&gt; Parameters: 1(Integer)<br>DEBUG 2022-04-13 12:33:40,060 demo.dao.ApartMapper: Cache Hit Ratio [demo.dao.ApartMapper]: 0.5<br>DEBUG 2022-04-13 12:33:40,060 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure><p>从此可以看出，前两次查询二级缓存有效，进行更新操作之后，第三次查询再次执行了SQL语句访问数据库，证明更新操作使得二级缓存进行了刷新。</p><h3 id="4、测试：二级缓存对映射器中多表查询时是否有效"><a href="#4、测试：二级缓存对映射器中多表查询时是否有效" class="headerlink" title="4、测试：二级缓存对映射器中多表查询时是否有效"></a>4、测试：二级缓存对映射器中多表查询时是否有效</h3><p>在我们进行级联查询的时候，涉及到了另一个namespace ，此时二级缓存是否有效呢？是否会引发脏数据问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session3</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> session1.getMapper(UserMapper.class);<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br>        <span class="hljs-type">ApartMapper</span> <span class="hljs-variable">mapper3</span> <span class="hljs-operator">=</span> session3.getMapper(ApartMapper.class);<br><br>        System.out.println(<span class="hljs-string">&quot;emp1读取内容：&quot;</span> + mapper1.findBid(<span class="hljs-number">1</span>));<br>        session1.commit();<br>        System.out.println(<span class="hljs-string">&quot;emp2读取内容：&quot;</span> + mapper2.findBid(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mapper3.update(<span class="hljs-string">&quot;物业部&quot;</span>, <span class="hljs-number">1</span>);<br>        session3.commit();<br>        System.out.println(<span class="hljs-string">&quot;emp2读取内容：&quot;</span> + mapper2.findBid(<span class="hljs-number">1</span>));<br>        System.out.println(i);<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 12:47:38,840 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 12:47:38,889 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>emp1读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 12:47:38,942 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.5<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 12:47:38,945 org.apache.ibatis.transaction.jdbc.JdbcTransaction: Opening JDBC Connection<br>DEBUG 2022-04-13 12:47:38,948 demo.dao.ApartMapper.update: ==&gt;  Preparing: update t<span class="hljs-built_in">_</span>dep set dname = ? where did = ? <br>DEBUG 2022-04-13 12:47:38,948 demo.dao.ApartMapper.update: ==&gt; Parameters: 物业部(String), 1(Integer)<br>DEBUG 2022-04-13 12:47:38,950 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.6666666666666666<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure><p>由此可见，二级缓存有效，但是存在脏数据。 当<code>sqlsession1</code>的mapper1查询数据后，二级缓存生效。保存在<code>StudentMapper</code>的<code>namespace</code>下的<code>cache</code>中。当<code>sqlSession3</code>的<code>mapper3</code>的<code>update</code>方法对class表进行更新时，<code>update</code>不属于<code>Mapper2的</code>namespace<code>，所以</code>Mapper2下的cache没有感应到变化，没有刷新缓存。当<code>Mapper2</code>中同样的查询再次发起时，从缓存中读取了脏数据。 </p><h3 id="5、测试：解决二级缓存脏数据问题"><a href="#5、测试：解决二级缓存脏数据问题" class="headerlink" title="5、测试：解决二级缓存脏数据问题"></a>5、测试：解决二级缓存脏数据问题</h3><p>在测试4的时候脏数据问题，经过多方查找资料，最终在美团大佬的文章中找到了我想要的答案， 可以使用Cache ref，让主查询引用子查询的命名空间，这样两个映射文件对应的SQL操作都使用的是同一块缓存了。</p><p>在被级联进行子查询的命名空间加入以下代码，让两个映射器对应的SQL操作都使用同一个缓存就ok了，此时进行更新操作就会强制刷新啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;cache-ref namespace=<span class="hljs-string">&quot;这里是进行查询的那个命名空间接口的全限定类名&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tex">DEBUG 2022-04-13 19:17:57,721 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 19:17:57,774 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 19:17:57,776 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>emp1读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 19:17:57,832 demo.dao.UserMapper: Cache Hit Ratio [demo.dao.UserMapper]: 0.3333333333333333<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;人事部&#x27;&#125;&#125;<br>DEBUG 2022-04-13 19:17:57,840 demo.dao.ApartMapper.update: ==&gt;  Preparing: update t<span class="hljs-built_in">_</span>dep set dname = ? where did = ? <br>DEBUG 2022-04-13 19:17:57,841 demo.dao.ApartMapper.update: ==&gt; Parameters: 物业部(String), 1(Integer)<br>DEBUG 2022-04-13 19:17:57,856 demo.dao.UserMapper.findBid: ==&gt;  Preparing: select eid,ename,gender,did from t<span class="hljs-built_in">_</span>emp where eid = ? <br>DEBUG 2022-04-13 19:17:57,858 demo.dao.ApartMapper.findByAid: ====&gt;  Preparing: select did,dname from t<span class="hljs-built_in">_</span>dep where did = ? <br>DEBUG 2022-04-13 19:17:57,862 demo.dao.UserMapper.findBid: &lt;==      Total: 1<br>emp2读取内容：Emp&#123;eid=1, ename=&#x27;王麻子&#x27;, gender=&#x27;人事部&#x27;, apart=Apart&#123;did=1, dname=&#x27;物业部&#x27;&#125;&#125;<br></code></pre></td></tr></table></figure><p>但是当然有得必有失，这样多个命名空间的操作会对缓存造成相应的影响。</p><p>二级缓存的源码相对感觉比较复杂，后续还需要深度理解后再补上吧，当然我们在实际开发中MyBatis的缓存特性用的不是很多，大多使用第三方如Redis、 Memcached 等分布式缓存比较多，当然深度理解了MyBatis缓存特性后第三方缓存工具会更加的顺手，最后感谢美团后端大姥，让我对MyBatis缓存有更加深入的了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于MyBatis-缓存&quot;&gt;&lt;a href=&quot;#关于MyBatis-缓存&quot; class=&quot;headerlink&quot; title=&quot;关于MyBatis_缓存&quot;&gt;&lt;/a&gt;关于MyBatis_缓存&lt;/h1&gt;&lt;h2 id=&quot;一、MyBatis缓存简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="MyBatis" scheme="http://121.43.167.55/tags/MyBatis/"/>
    
    <category term="缓存" scheme="http://121.43.167.55/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis学习笔记(一)</title>
    <link href="http://121.43.167.55/2022/021146721.html"/>
    <id>http://121.43.167.55/2022/021146721.html</id>
    <published>2022-02-11T01:52:22.000Z</published>
    <updated>2022-07-14T12:06:34.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、关于MyBatis"><a href="#一、关于MyBatis" class="headerlink" title="一、关于MyBatis"></a>一、关于MyBatis</h1><p>&amp;emsp;&amp;emsp;持久层可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏（大部分的重要数据都会有相关的备份机制)，在断电或者其他情况下，重新开启系统仍然可以读取这些数据。</p><p>&amp;emsp;&amp;emsp; Mybatis 是一个优秀的持久层框架，它对 jdbc 的操作数据库的过程进行封装，使得开发者只需要专注 于 SQL 语句本身，而不用去关心注册驱动，创建 connection 等 Mybatis 通过 xml 文件配置或者注解的方式将要执行的各种 statement 配置起来，并通过 java 对象 和statement中的sql进行映射成最终执行的sql语句，最后由Mybatis框架执行sql并将结果映射成java 对象并返回。 </p><p>&amp;emsp;&amp;emsp; 不屏蔽 SQL 意味着可以更为精确地定位 SQL 语句，可以对其进行优化和改造， 这有利于互联网系统性能的提高，符合互联网需要性能优化的特点。 </p><p>&amp;emsp;&amp;emsp;并且它提供强大、灵活的映射机制 ，方便 Java 开发者使用 。提供动态 SQL 的功能，允许 我们根据不同条件组装 SQL ，这个功能远比其他工具或者 Java 编码的可读性和可维 护性高得多，满足各种应用系统的同时也满足了需求经常变化的互联网应用的要 求。 </p><p>&amp;emsp;&amp;emsp;在MyBatis 中，提供了使用 Mapper 的接口编程，只要 个接口和 XML 就能创 建映射器，进一步简化我们的工作，使得很多框架 API MyBatis 中消失，开发者 能更集中于业务逻辑 。</p><h1 id="二、MyBatis的核心组件"><a href="#二、MyBatis的核心组件" class="headerlink" title="二、MyBatis的核心组件"></a>二、MyBatis的核心组件</h1><p>&amp;emsp;&amp;emsp;MyBatis的核心组件分为四个部分：</p><p>&amp;emsp;&amp;emsp;1.SqlSessionFactoryBuilder(构造器)：它会根据配置或者代码来生成SqlSessionFactory采用的是分布构建的Builder模式。</p><p>&amp;emsp;&amp;emsp;2.SqlSessionFactory (工厂接口)：依靠它来生成 SqlSession，使用的是工厂模式。</p><p>&amp;emsp;&amp;emsp;3.SqlSession（会话):一个既可以发送SQL执行返回结果，也可以获取 Mapper 的接口。在现有的技术中，一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis提供的SQL Mapper 接口编程技术，它能提高代码的可读性和可维护性。</p><p>&amp;emsp;&amp;emsp;4.SQL Mapper（映射器):MyBatis 新设计存在的组件，它由一个Java 接口和 XML文件（或注解）构成，需要给出对应的SQL 和映射规则。它负责发送SQL去执行,并返回结果。</p><h1 id="三、使用XML构建SQLSessionFactory"><a href="#三、使用XML构建SQLSessionFactory" class="headerlink" title="三、使用XML构建SQLSessionFactory"></a>三、使用XML构建SQLSessionFactory</h1><p>&amp;emsp;&amp;emsp;在MyBatis中的XML文件分为两类，一类是基础配置文件，通常只有一个，主要是配置一些最基本的上下文参数和运行环境；另一类是映射文件，它可以配置映射关系、SQL、参数等信息。</p><p>&amp;emsp;&amp;emsp;通常命名为MyBatis_config.xml,代码清单如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    引入XML的约束文件，约束内容</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在jdbc.properties属性文件中配置数据库四要素--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--设置全限定类名的别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.dyh.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--配置数据库连接--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.Driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.Url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.UserName&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.UserPassword&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-comment">&lt;!--扫描映射器包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.dyh.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;typeAlias元素：定义了一个别名role，它代表着com.learn.ssm.chapter3.pojo.Role这个类。这样定义后，在 MyBatis 上下文中就可以使用别名去代替全限定名了。<br>&amp;emsp;&amp;emsp;environment元素：的定义，这里描述的是数据库。它里面的<code>&lt;transactionManager&gt;</code>元素是配置事务管理器，这里采用的是 MyBatis的JDBC管理器方式。然后采用<code>&lt;dataSource&gt;</code>元素配置数据库，其中属性 type&#x3D;”POOLED”代表采用MyBatis内部提供的连接池方式,最后定义一些关于JDBC的属性信息。<br>&amp;emsp;&amp;emsp;mapper元素：代表引入的那些映射器，它里面的 package 属性会扫描整个包取到里面的所有映射器。</p><h1 id="四、SQLSession"><a href="#四、SQLSession" class="headerlink" title="四、SQLSession"></a>四、SQLSession</h1><p>&amp;emsp;&amp;emsp;在MyBatis 中, SqISession是其核心接口。在MyBatis中有两个实现类, DefaultSqlSession和SqlSessionManager。DefaultSqlSession是单线程使用的，而SqlSessionManager在多线程环境下使用。SqlSession的作用类似于一个 JDBC 中的 Connection对象，代表着一个连接资源的启用。具体而言，它的作用有3个：获取Mapper接口，发送SQL给数据库，控制数据库事务。</p><p>&amp;emsp;&amp;emsp;有了SqlSessionFactory创建SqlSession是非常简单的，注意SqlSession只是一个门面接口，真正执行业务语句的是底层的Executor！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dyh.utlis;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: MybatisUtils</span><br><span class="hljs-comment"> * Package: com.dyh.utils</span><br><span class="hljs-comment"> * Description: 工具类：一个类中的所有方法都是静态方法，不需要实例化对象，所以私有化构造方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/4/4 17:18</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: yangzhihong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MybatisUtils</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SqlSessionFactory <span class="hljs-title function_">getSqlSessionFactory</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(sqlSessionFactory != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>  sqlSessionFactory;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis_config.xml&quot;</span>);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(is);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(sqlSessionFactory == <span class="hljs-literal">null</span>) &#123;<br>            getSqlSessionFactory();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;SqlSession控制数据库事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.dyh.test;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: MainTest</span><br><span class="hljs-comment"> * Package: com.dyh.test</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/4/4 16:21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: yangzhihong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            session = MybatisUtils.getSqlSession();<br><br>            <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">employeeMapper</span> <span class="hljs-operator">=</span> session.getMapper(EmployeeMapper.class);<br><br>            <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.getEmployee(<span class="hljs-number">1</span>);<br><br>            System.out.println(employee);<br><br>            session.commit();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-keyword">if</span>(session != <span class="hljs-literal">null</span>) &#123;<br>                session.rollback(); <span class="hljs-comment">// 回滚</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(session != <span class="hljs-literal">null</span>) &#123;<br>                session.close();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;这里使用commit方法提交事务，或者使用rollback方法回滚事务。因为它代表着一个数据库的连接资源，使用后要及时关闭它，如果不关闭，那么数据库的连接资源就会很快被耗费光,整个系统就会陷入瘫痪状态，所以用finally语句保证其顺利关闭。<br>&amp;emsp;&amp;emsp;由于SqlSession的获取 Mapper接口和发送SQL的功能需要先实现映射器的功能，而映射器接口也可以实现发送SQL 的功能。</p><h1 id="五、映射器"><a href="#五、映射器" class="headerlink" title="五、映射器"></a>五、映射器</h1><p>&amp;emsp;&amp;emsp;映射器是MyBatis中最重要也是最复杂的组件，它由一个接口和一个对应的XML文件组成。</p><p>&amp;emsp;&amp;emsp;它可以配置以下内容：</p><ul><li>&amp;emsp;&amp;emsp;描述映射规则</li><li>&amp;emsp;&amp;emsp;提供SQL语句，并可以配置SQL参数类型、返回类型、缓存刷新等信息</li><li>&amp;emsp;&amp;emsp;配置缓存</li><li>&amp;emsp;&amp;emsp;提供动态SQL</li></ul><h2 id="使用XML文件实现映射器"><a href="#使用XML文件实现映射器" class="headerlink" title="使用XML文件实现映射器"></a>使用XML文件实现映射器</h2><p>定义一个映射器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br>    Employee <span class="hljs-title function_">getEmployee</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;demo.dao.ApartMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTask&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.dyh.pojo.Task&quot;</span>&gt;</span><br>        select id,title,context,note from t_task where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;<code>&lt;mapper&gt;</code>元素中的属性namcspace 所对应的是一个接口的全限定名，于是 MyBatis上下文就可以通过它找到对应的接口。</p><p>&amp;emsp;&amp;emsp;<code>&lt;select&gt;</code>元素表明这是一条查询语句，而属性 id标识了这条 SQL，属性parameterType&#x3D;”long”说明传递给SQL的是一个long型的参数,而resultType&#x3D;”role”表示返回的是一个role类型的返回值。而role是之前配置文件 mybatis-config.xml配置的别名，指代的是com.learn.ssm.chapter3.pojo.Role。<br>&amp;emsp;&amp;emsp;这条SQL 中的#{id}表示传递进去的参数。<br>&amp;emsp;&amp;emsp;注意，我们并没有配置SQL执行后和 role的对应关系，它是如何映射的呢?其实这里采用的是一种被称为自动映射的功能，MyBatis在默认情况下提供自动映射，只要SQL返回的列名能和POJO对应起来即可。这里SQL返回的列名id和note是可以和之前定义的POJO的属性对应起来的,而表里的列role_name通过SQL别名的改写,使其成为roleName,也是和 POJO对应起来的，所以此时MyBatis就可以把SQL查询的结果通过自动映射的功能映射成为一个POJO。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、关于MyBatis&quot;&gt;&lt;a href=&quot;#一、关于MyBatis&quot; class=&quot;headerlink&quot; title=&quot;一、关于MyBatis&quot;&gt;&lt;/a&gt;一、关于MyBatis&lt;/h1&gt;&lt;p&gt;&amp;amp;emsp;&amp;amp;emsp;持久层可以将业务数据存储到磁</summary>
      
    
    
    
    
    <category term="MyBatis" scheme="http://121.43.167.55/tags/MyBatis/"/>
    
    <category term="持久层框架" scheme="http://121.43.167.55/tags/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库基本操作</title>
    <link href="http://121.43.167.55/2021/111060282.html"/>
    <id>http://121.43.167.55/2021/111060282.html</id>
    <published>2021-11-10T11:16:28.000Z</published>
    <updated>2022-07-14T12:06:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库之基本操作"><a href="#MySQL数据库之基本操作" class="headerlink" title="MySQL数据库之基本操作"></a>MySQL数据库之基本操作</h1><h2 id="一、SQL分类"><a href="#一、SQL分类" class="headerlink" title="一、SQL分类"></a>一、SQL分类</h2><p>SQL语言以功能分类： </p><p>&amp;emsp;&amp;emsp;<strong>DDL（Data Definition Languages、数据定义语言）</strong>:这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等。 </p><p>&amp;emsp;&amp;emsp;<strong>DML（Data Manipulation Language、数据操作语言）</strong>:用于添加、删除、更新和查询数据库记 录，并检查数据完整性。 主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等。 SELECT是SQL语言的基础，最为重要。 </p><p>&amp;emsp;&amp;emsp;<strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和 安全级别。 主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。 </p><p>&amp;emsp;&amp;emsp;还有因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：<strong>DQL（数据查询语言）</strong>。 还有单独将 COMMIT 、 ROLLBACK 取出来称为<strong>TCL （Transaction Control Language，事务控制语 言）</strong>。 </p><h2 id="二、建库与建表"><a href="#二、建库与建表" class="headerlink" title="二、建库与建表"></a>二、建库与建表</h2><p>&amp;emsp;&amp;emsp;建库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE 表名;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee(<br>    字段名陈 数据类型 [约束],<br>    <span class="hljs-comment">--将emp_id设置为主键</span><br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_addr <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_mobile <span class="hljs-type">INT</span><br>);<br></code></pre></td></tr></table></figure><h2 id="三、增加数据的语法"><a href="#三、增加数据的语法" class="headerlink" title="三、增加数据的语法"></a>三、增加数据的语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名[(字段列表)] <span class="hljs-keyword">values</span>(值列表);<br></code></pre></td></tr></table></figure><p>情况一：给指定的表中所有字段添加数据</p><p>&amp;emsp;&amp;emsp;如果是主键且自动增长的列，可以不给该列显式赋值，也可以显式赋值：可以给自定义的值（不可以重复），也可以给null。</p><p>&amp;emsp;&amp;emsp;如果给表中的所有字段添加数据，数据列可以省略。</p><p>情况二： 给指定的表中部分字段添加数据</p><p>&amp;emsp;&amp;emsp;部分字段必须显式指定字段列表不允许为空的字段必须要填的，允许为空的或者有默认值的、自动增长的字段可以不填。</p><p>&amp;emsp;&amp;emsp;如果指定的字段列表和值列表，字段列表和值列表只要一一对应，可以不和数据库中的列表顺序一致。</p><p>&amp;emsp;&amp;emsp;开发中: 即使在给所有字段添加数据时可以省略字段列表，但是建议显式给出你要添加的字段列表，可读性是很好的，而且SQL语句的性能要高。</p><h2 id="四、主键与外键"><a href="#四、主键与外键" class="headerlink" title="四、主键与外键"></a>四、主键与外键</h2><h3 id="主键："><a href="#主键：" class="headerlink" title="主键："></a>主键：</h3><p>&amp;emsp;&amp;emsp;在创建表时设置主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> employee(<br>    字段名陈 数据类型 [约束],<br>    <span class="hljs-comment">-- 1.将emp_id设置为主键</span><br>emp_id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>emp_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_addr <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>emp_mobile <span class="hljs-type">INT</span><br>    <span class="hljs-comment">-- 2.联合主键</span><br>    <span class="hljs-keyword">PRIMARY</span> KEY(emp_id,emp_name)<br>);<br></code></pre></td></tr></table></figure><h3 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h3><p><strong>【方式一】在创建表的时候进行添加</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">[<span class="hljs-keyword">CONSTRAINT</span> symbol] <span class="hljs-keyword">FOREIGN</span> KEY [id] (从表的字段<span class="hljs-number">1</span>) <span class="hljs-keyword">REFERENCES</span> tbl_name (主表的字段<span class="hljs-number">2</span>) [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> &#123;RESTRICT <span class="hljs-operator">|</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION&#125;] [<span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> &#123;RESTRICT <span class="hljs-operator">|</span> CASCADE <span class="hljs-operator">|</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> ACTION&#125;<br></code></pre></td></tr></table></figure><p>上面的代码是同一行，中括号里的内容是可选项。</p><p>解释如下：</p><p>CONSTRAINT symbol：可以给这个外键约束起一个名字，有了名字，以后找到它就很方便了。如果不加此参数的话，系统会自动分配一个名字。</p><p>FOREIGN KEY：将从表中的字段1作为外键的字段。</p><p>REFERENCES：映射到主表的字段2。</p><p>ON DELETE后面的四个参数：代表的是当删除主表的记录时，所做的约定。</p><p>RESTRICT(限制)：如果你想删除的那个主表，它的下面有对应从表的记录，此主表将无法删除。</p><p>CASCADE(级联)：如果主表的记录删掉，则从表中相关联的记录都将被删掉。</p><p>SET NULL：将外键设置为空。</p><p>NO ACTION：什么都不做。</p><p>注：一般是RESTRICT和CASCADE用的最多。</p><p><strong>【方式二】表已经创建好了，继续修改表的结构来添加外键。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> employee <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">FOREIGN</span> KEY(dept_id) <span class="hljs-keyword">REFERENCES</span> department(id);<br></code></pre></td></tr></table></figure><p>解释如下：</p><p>ALTER TABLE employee：在从表employee中进行操作；</p><p>ADD FOREIGN KEY(dept_id)：将从表的字段dept_id添加为外键；</p><p>REFERENCES department(id)：映射到主表department当中为id的字段。</p><h2 id="五、删除数据的语句"><a href="#五、删除数据的语句" class="headerlink" title="五、删除数据的语句"></a>五、删除数据的语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件];   只删除表中的记录，不会删除表<br><span class="hljs-keyword">truncate</span> 表名;   将整张表删除，创建一个一模一样结构的新表<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;delete from 表名; 将表中的所有数据删除，从表中的数据中将符合条件的数据都过滤掉，使用[where 条件]   这是可选的，表示 where子句，可以设置的条件。</p><p>&amp;emsp;&amp;emsp;where子句可以用在delete、update、select中，where 结果表达式是一个布尔值。</p><p>&amp;emsp;&amp;emsp;比较运算符：&#x3D; 、!&#x3D;（&lt;&gt;）、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;</p><p>&amp;emsp;&amp;emsp;如果在where 子句中，需要和null进行判断,不能使用 &#x3D;   ！&#x3D; ,而是使用  is null或者is not null。</p><p>&amp;emsp;&amp;emsp;逻辑运算符:and逻辑与、or逻辑或、not逻辑非、between and 等价于  &gt;&#x3D;  and  &lt;&#x3D;。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.删除学号为10的学生信息</span><br><span class="hljs-comment">-- 执行流程：删除时</span><br><span class="hljs-comment">-- 从上往下一行行记录进行比较</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">-- 2.删除年龄大于等于30的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">-- 3.删除学生地址为湘潭大学的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_addr <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;湘潭大学&#x27;</span>;<br><br><span class="hljs-comment">-- 4.删除地址不为软件学院的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_addr <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;软件学院&#x27;</span>;<br><br><br><span class="hljs-comment">-- 5. 删除年龄在20~40之间学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student <br><span class="hljs-keyword">where</span> stu_age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">and</span> stu_age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">-- 6.使用between and</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_age <span class="hljs-keyword">between</span> <br><span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">40</span>;<br><br><span class="hljs-comment">-- 7.删除学号为13或手机号码为</span><br><span class="hljs-comment">-- 2222的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_id <span class="hljs-operator">=</span> <span class="hljs-number">13</span> <span class="hljs-keyword">or</span> stu_mobile <span class="hljs-operator">=</span> <span class="hljs-number">2222</span>;<br><br><span class="hljs-comment">-- 8.删除地址为null的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_addr <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br><br><span class="hljs-comment">-- 9.删除手机号不为空的学生信息</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_mobile <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br><br></code></pre></td></tr></table></figure><h2 id="六、修改数据的语句"><a href="#六、修改数据的语句" class="headerlink" title="六、修改数据的语句"></a>六、修改数据的语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> 表名 <span class="hljs-keyword">set</span> 字段<span class="hljs-number">1</span><span class="hljs-operator">=</span>新值,... [<span class="hljs-keyword">where</span> 条件];<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.修改所有学生的地址</span><br><span class="hljs-comment">-- 为&#x27;中南大学&#x27;</span><br><span class="hljs-keyword">update</span> student <br><span class="hljs-keyword">set</span> stu_addr<span class="hljs-operator">=</span><span class="hljs-string">&#x27;中南大学&#x27;</span><br><br><span class="hljs-comment">-- 2.修改学号为10的学生地址</span><br><span class="hljs-comment">-- 为上海大学</span><br><span class="hljs-keyword">update</span> student <br><span class="hljs-keyword">set</span> stu_addr <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;上海大学&#x27;</span><br><span class="hljs-keyword">where</span> stu_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><br><span class="hljs-comment">-- 修改多个字段</span><br><span class="hljs-comment">-- 修改学号5~10学生的</span><br><span class="hljs-comment">-- 地址为&#x27;南京大学&#x27;和</span><br><span class="hljs-comment">-- 手机号码为&#x27;080-1179&#x27;</span><br><span class="hljs-keyword">update</span> student<br><span class="hljs-keyword">set</span> stu_addr <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;南京大学&#x27;</span>,<br>    stu_mobile <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;080-1179&#x27;</span><br><span class="hljs-keyword">where</span> stu_id <span class="hljs-keyword">between</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">update</span> student <br><span class="hljs-keyword">set</span> stu_addr <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;北京大学&#x27;</span><br><span class="hljs-keyword">where</span> stu_id <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><h2 id="七、单表查询操作"><a href="#七、单表查询操作" class="headerlink" title="七、单表查询操作"></a>七、单表查询操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> 字段列表 <span class="hljs-keyword">from</span> 表名<br>[<span class="hljs-keyword">where</span> 子句]<br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 子句]<br>[<span class="hljs-keyword">having</span> 子句]<br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> 子句]<br>[limit 子句]<br></code></pre></td></tr></table></figure><ol><li><p>select 字段列表 from 表名; 如果查询所有字段可以*通配符</p></li><li><p>select 指定的字段 from 表名;</p></li><li><p>别名： 可以给结果集中的字段名称设置别名：select 字段名1 as 别名1, 字段名2 别名2… from 表名</p></li><li><p>where 子句： 从一组记录中筛选出符合条件的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.查询出所有学生所有信息</span><br><span class="hljs-keyword">select</span> stu_id, stu_name, stu_age, stu_mobile, stu_addr<br><span class="hljs-keyword">from</span> student;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student;<br><br><span class="hljs-comment">-- 2. 查询出所有学生指定的部分字段: 姓名和年龄</span><br><span class="hljs-comment">-- select语句查询出的结果称为结果集</span><br><span class="hljs-comment">-- select 除了可以查询出结果还是SQL语句的输出语句</span><br><span class="hljs-keyword">select</span> stu_name, stu_age <span class="hljs-keyword">from</span> student;<br><br><span class="hljs-keyword">select</span> stu_name <span class="hljs-keyword">as</span> 学生姓名, stu_age 学生年龄<br><span class="hljs-keyword">from</span> student;<br><br><br><span class="hljs-comment">-- 3.查询出学号在5~10学生姓名、手机号码信息</span><br><span class="hljs-keyword">select</span> <br>stu_name <span class="hljs-keyword">as</span> 姓名, stu_mobile <span class="hljs-keyword">as</span> 手机号码<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_id <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> stu_id <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span><br><br><span class="hljs-comment">-- 4. 查询出地址为中南大学或者</span><br><span class="hljs-comment">-- 南京大学学生信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> stu_addr<span class="hljs-operator">=</span><span class="hljs-string">&#x27;中南大学&#x27;</span><br><span class="hljs-keyword">or</span> stu_addr<span class="hljs-operator">=</span><span class="hljs-string">&#x27;南京大学&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL数据库之基本操作&quot;&gt;&lt;a href=&quot;#MySQL数据库之基本操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库之基本操作&quot;&gt;&lt;/a&gt;MySQL数据库之基本操作&lt;/h1&gt;&lt;h2 id=&quot;一、SQL分类&quot;&gt;&lt;a href=&quot;#一、</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://121.43.167.55/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://121.43.167.55/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go语言_初识Go语言</title>
    <link href="http://121.43.167.55/2021/110858220.html"/>
    <id>http://121.43.167.55/2021/110858220.html</id>
    <published>2021-11-08T03:07:02.000Z</published>
    <updated>2022-07-14T12:05:54.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言-初识Go语言"><a href="#Go语言-初识Go语言" class="headerlink" title="Go语言_初识Go语言"></a>Go语言_初识Go语言</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go语言-初识Go语言&quot;&gt;&lt;a href=&quot;#Go语言-初识Go语言&quot; class=&quot;headerlink&quot; title=&quot;Go语言_初识Go语言&quot;&gt;&lt;/a&gt;Go语言_初识Go语言&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="Go" scheme="http://121.43.167.55/tags/Go/"/>
    
    <category term="Golang" scheme="http://121.43.167.55/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Javascript_DOM操作</title>
    <link href="http://121.43.167.55/2021/101839553.html"/>
    <id>http://121.43.167.55/2021/101839553.html</id>
    <published>2021-10-18T00:37:56.000Z</published>
    <updated>2022-07-14T12:05:25.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript-DOM操作"><a href="#Javascript-DOM操作" class="headerlink" title="Javascript_DOM操作"></a>Javascript_DOM操作</h1><h2 id="一、关于Javascript与DOM"><a href="#一、关于Javascript与DOM" class="headerlink" title="一、关于Javascript与DOM"></a>一、关于Javascript与DOM</h2><h3 id="1-JavaScript"><a href="#1-JavaScript" class="headerlink" title="1.JavaScript"></a>1.JavaScript</h3><p>JavaScript简称JS，是一种解释型脚本语言。</p><p>JavaScript是一种轻量级编程语言。</p><p>JavaScript是可插入HTML页面的编程代码。</p><p>JavaScript插入HTML页面后，基本上所有现代浏览器都可执行。</p><p>JavaScript预解析，  js引擎会把js里面所有的var和function提升到当前作用域的最前面，所以非常神奇的是变量和函数可以先使用再声明。</p><p>&amp;emsp;&amp;emsp;她可由为网页添加各种样式的动态功能，为用户提供更流畅更美观的浏览效果，通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的 。</p><h3 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2.DOM"></a>2.DOM</h3><p>DOM全称： Document Object Model （文本对象模型）。</p><p> &amp;emsp; 当网页被加载时，浏览器会创建页面的文档对象模型。是W3C推荐的处理可扩展标记语言（HTML和XML）的标准编程接口。DOM:对节点结构化表诉，并定义了一种方式可以使程序对该结构进行访问，将web页面和脚本语言连接起来。</p><p> &amp;emsp; 通过DOM接口可以改变网页的内容、结构和样式。</p><p> &amp;emsp; 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML：</p><p> &amp;emsp; JavaScript 能够改变页面中的所有 HTML<br> &amp;emsp; 元素 JavaScript 能够改变页面中的所有 HTML 属性<br> &amp;emsp; JavaScript 能够改变页面中的所有 CSS 样式<br> &amp;emsp; JavaScript 能够对页面中的所有事件做出反应</p><p>DOM是一种树状结构：</p><p><img src="https://cdn.jsdelivr.net/gh/yang-sir-one/yangimg/JSDOM.png"></p><p><strong>document对象：</strong></p><p> &amp;emsp; 当浏览器载入HTML文档，她就会成为Document对象。</p><p> &amp;emsp; 而Document对象是HTML文档的根节点，使我们可以从脚本中对页面的所有元素进行访问，并且Document对象是Window对象的一部分，可以通过Window.document进行访问。</p><h2 id="二、DOM操作"><a href="#二、DOM操作" class="headerlink" title="二、DOM操作"></a>二、DOM操作</h2><h3 id="查询常用操作："><a href="#查询常用操作：" class="headerlink" title="查询常用操作："></a>查询常用操作：</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">document.getElementById()</td><td align="center">返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td align="center">document.getElementsByClassName()</td><td align="center">返回文档中所有指定类名的元素集合，作为 NodeList 对象返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td align="center">document.getElementsByTagName()</td><td align="center">返回带有指定标签名的对象集合</td></tr><tr><td align="center">document.getElementsByName()</td><td align="center">返回带有指定名称的对象集合</td></tr></tbody></table><p>案例：</p><p> &amp;emsp; 以简单输入框模拟前端用户操作，以表格模拟后台数据处理。</p><p> &amp;emsp; 以JavaScript实现，对数据写入、删除、修改、隔行变色的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!--<br> * @<span class="hljs-title class_">Author</span>: yangzhihong<br> * @<span class="hljs-title class_">Date</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">17</span> <span class="hljs-number">14</span>:<span class="hljs-number">23</span>:<span class="hljs-number">21</span><br> * @<span class="hljs-title class_">LastEditors</span>: yangzhihong<br> * @<span class="hljs-title class_">LastEditTime</span>: <span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span> <span class="hljs-number">10</span>:<span class="hljs-number">43</span>:<span class="hljs-number">17</span><br> * @<span class="hljs-title class_">FilePath</span>: \<span class="hljs-attr">golang_coded</span>:\大云汉<span class="hljs-title class_">IT2021</span>\大云汉前端\测试\<span class="hljs-variable constant_">DOM</span>节点操作（表单）.<span class="hljs-property">html</span><br> * @<span class="hljs-title class_">Description</span>: <br>--&gt;<br>&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    姓名：&lt;input type=&quot;text&quot; id=&quot;uname&quot;&gt;&lt;br&gt;<br>    年龄：&lt;input type=&quot;number&quot; id=&quot;age&quot; min=&quot;0&quot; max=&quot;150&quot;&gt;&lt;br&gt;<br>    手机号：&lt;input type=&quot;text&quot; id=&quot;mobile&quot;&gt;&lt;br&gt;<br>    &lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;subBtn&quot;&gt;<br>    &lt;hr&gt;<br><br>    &lt;table id=&quot;users&quot; border=&quot;1&quot; cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; width=&quot;70%&quot; align=&quot;center&quot;&gt;<br>      &lt;tr&gt;<br>        &lt;th&gt;序号&lt;/th&gt;<br>        &lt;th&gt;姓名&lt;/th&gt;<br>        &lt;th&gt;年龄&lt;/th&gt;<br>        &lt;th&gt;手机号&lt;/th&gt;<br>        &lt;th&gt;操作&lt;/th&gt;<br>      &lt;/tr&gt;<br>    &lt;/table&gt;<br><br>    &lt;script type=&quot;text/javascript&quot;&gt;<br>      //定义一个数组<br>      var users = [<br>        &#123;<br>          uname: &#x27;小刘&#x27;,<br>          age: 23,<br>          mobile: &#x27;17670394021&#x27;<br>        &#125;,<br>        &#123;<br>          uname: &#x27;小杨&#x27;,<br>          age: 20,<br>          mobile: &#x27;17670394021&#x27;<br>        &#125;,<br>        &#123;<br>          uname: &#x27;小周&#x27;,<br>          age: 18,<br>          mobile: &#x27;17670394021&#x27;<br>        &#125;<br>      ];<br><br>      // 获取各个节点对象<br>      var unameEle = document.querySelector(&#x27;#uname&#x27;);<br>      var ageEle = document.querySelector(&#x27;#age&#x27;);<br>      var mobileEle = document.querySelector(&#x27;#mobile&#x27;);<br>      var subBtn = document.querySelector(&#x27;#subBtn&#x27;);<br>      var userTable = document.querySelector(&#x27;#users&#x27;);<br><br>      // 使用一个变量来记录初始值<br>      // innerHTML是DOM的一个属性，可以获取到该对象元素的内容<br>      var tableText = userTable.innerHTML;<br>      // 渲染，对表格内容进行初始化<br>      renderTable(userTable, users);<br><br>      // 给按钮注册点击事件<br>      subBtn.onclick = function() &#123;<br>        // 获取到姓名、年龄、手机号<br>        // 当点击提交按钮时对三个值进行操作<br>        var uname = unameEle.value;<br>        var age = ageEle.value;<br>        var mobile = mobileEle.value;<br><br>        // 判断数据是否合法<br>        if(uname == &#x27;&#x27; || uname == null) &#123;<br>          alert(&#x27;用户名不合法！&#x27;);<br>          return;<br>        &#125;<br><br>        // 判断数据是否合法<br>        if(age == &#x27;&#x27; || age == null) &#123;<br>          alert(&#x27;用户名不合法！&#x27;);<br>          return;<br>        &#125;<br><br>        // 判断数据是否合法<br>        if(mobile == &#x27;&#x27; || mobile == null) &#123;<br>          alert(&#x27;用户名不合法！&#x27;);<br>          return;<br>        &#125;<br><br>        //使用正则表达式校验手机号<br>        var mobileRegExp = /^1[345789]\d&#123;9&#125;$/;<br>        <br>        if(!mobileRegExp.test(mobile)) &#123;<br>          alert(&#x27;您输入的手机号格式错误！&#x27;)<br>          return;<br>        &#125;<br><br>        // 事件，创建JS对象<br>        var user = &#123;&#125;;<br>        user.uname = uname;<br>        user.age = age;<br>        user.mobile = mobile;<br><br>        // 将新增的对象添加到数组当中<br>        users.push(user);<br><br>        // 清空填写表单数据<br>        unameEle.value = &#x27;&#x27;;<br>        ageEle.value = &#x27;&#x27;;<br>        mobileEle.value = &#x27;&#x27;;<br><br>        // 对表格进行数据渲染<br>        renderTable(userTable, users);<br><br>        // 弹窗提示<br>        alert(&#x27;提交成功！&#x27;);<br>      &#125;<br><br><br>        // 渲染前端效果（将数组中的数据渲染到表格当中）<br>        function renderTable(ele,date) &#123;<br>          if (ele == null) &#123;<br>            alert(&#x27;请传入一个节点对象&#x27;);<br>          &#125;<br>          if (date == null || date.length == 0) &#123;<br>            alert(&#x27;请传入数组数据&#x27;);<br>          &#125;<br>          // 将表格还原为最初状态<br>          ele.innerHTML = tableText;<br>          <br>          // 循环数组<br>          for (var index in date) &#123;<br>            // 根据下标判断<br>            // 1.创建新的tr行<br>            var newTr = document.createElement(&#x27;tr&#x27;);<br>            newTr.align = &#x27;center&#x27;;<br><br>            // 根据下标奇偶性进行隔行变色<br>            if (index % 2 == 0) &#123;<br>              newTr.style = &#x27;background-color: pink&#x27;;<br>            &#125;<br>            <br>            // 将数组中的对象值传入前端tr行中<br>            newTr.innerHTML = &#x27;&lt;td&gt;&#x27;+index+&#x27;&lt;/td&gt;&lt;td class=&quot;uname&quot;&gt;&#x27;+date[index].uname+&#x27;&lt;/td&gt;&lt;td&gt;&#x27;+date[index].age+&#x27;&lt;/td&gt;&lt;td&gt;&#x27;+date[index].mobile+&#x27;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;#&quot; onclick=&quot;delByIndex(&#x27;+index+&#x27;)&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;&#x27;;<br>                <br>            // 2.将新tr追加到table中<br>            ele.appendChild(newTr);<br>          &#125;<br><br>          // 获取所有的用户名的td<br>  var tds = document.querySelectorAll(&#x27;.uname&#x27;);<br><br>          // 给每个td绑定鼠标双击事件<br>          for(var i=0; i&lt;tds.length; i++) &#123;<br>            tds[i].ondblclick = function() &#123;<br>              var uname = this.innerHTML;<br>              this.innerHTML = &#x27;&lt;input onblur=&quot;updateUname(event)&quot;  type=&quot;text&quot; value=&quot;&#x27;+uname+&#x27;&quot;&gt;&#x27;<br>            &#125;<br>          &#125;<br>        &#125;<br><br>        // 修改用户名的方法<br>        function updateUname(event) &#123;<br>          // 事件对象.target 属性获取数据源<br>          var updateUname = event.target.value;<br>          // 获取父节点对象<br>          var td = event.target.parentNode;<br>          td.innerHTML = updateUname;<br>          <br>          //获取焦点与失去焦点<br>          var preTd = td.previousElementSibling;<br>          var index = parseInt(preTd.innerHTML);<br>          users[index].uname = updateUname;<br>          <br>          console.log(users);<br>        &#125;<br><br>        function delByIndex(index) &#123;<br>// console.log(index);<br>if(confirm(&#x27;您确认要删除这个用户信息吗?&#x27;)) &#123;<br>users.splice(index, 1);<br>renderTable(userTable, users);<br>&#125;<br>return false;<br>&#125;<br><br>// 一个函数和一个节点的世界属性绑定在一起，而函数<br>// 定义在全局，函数的this是window，我如何获取到<br>// 这个事件的触发对象（事件源），函数被事件触发<br>// 因为js是基于事件驱动的，自动在事件触发时，将一个<br>// 事件对象传入给绑定的函数<br>    &lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Javascript-DOM操作&quot;&gt;&lt;a href=&quot;#Javascript-DOM操作&quot; class=&quot;headerlink&quot; title=&quot;Javascript_DOM操作&quot;&gt;&lt;/a&gt;Javascript_DOM操作&lt;/h1&gt;&lt;h2 id=&quot;一、关于Javas</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://121.43.167.55/tags/JavaScript/"/>
    
    <category term="DOM" scheme="http://121.43.167.55/tags/DOM/"/>
    
    <category term="HTML" scheme="http://121.43.167.55/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_线程优先级、线程安全与同步</title>
    <link href="http://121.43.167.55/2021/100161880.html"/>
    <id>http://121.43.167.55/2021/100161880.html</id>
    <published>2021-10-01T00:57:25.000Z</published>
    <updated>2022-07-14T12:05:07.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程-线程优先级、线程安全与同步"><a href="#Java多线程-线程优先级、线程安全与同步" class="headerlink" title="Java多线程_线程优先级、线程安全与同步"></a>Java多线程_线程优先级、线程安全与同步</h1><h2 id="一、线程优先级与常用API"><a href="#一、线程优先级与常用API" class="headerlink" title="一、线程优先级与常用API"></a>一、线程优先级与常用API</h2><p>&amp;emsp;&amp;emsp;每个线程执行时都有一定的优先级，优先级高的获取较多的执行机会，优先级低的线程则较少。线程默认的优先级与父线程优先级相同，Thread类提供了setPriority(int newPriority)、getPriority()方法来设置和返回指定线程的优先级，其中setPriority()方法的参数范围在1-10之间，也可以使用Thread类的三个常量(如下)，这三个静态常量来设置优先级可以保证程序会有更好的可移植性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The minimum priority that a thread can have.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The default priority that is assigned to a thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The maximum priority that a thread can have.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>    常用API有：</p><p>    int getPriority()  :  返回线程的优先级</p><p>    void setPriority() : 设置优先级</p><p>    Thread.State getState() : 返回线程的当前状态</p><p>    boolean isAlive() : 是否是活动状态</p><p>    void setDaemon() : 设置线程为守护线程，当Java虚拟机退出时，所有的守护线程都终止</p><p>    boolean isDaemon() : 判断当前线程是否是守护线程</p><p>    void join()<br>    void join(long millis)</p><p>    static void sleep(long millis) : </p><p>    static void yield() : </p><p>    相同点：</p><p>    1.都是Thread类的静态方法。</p><p>    2.进入同步代码块或方法，被监视器锁锁定的线程遇到这两个方法，都不会释放锁。</p><p>    不同点： </p><p>    1.sleep()方法将当前线程进入超时等待状态。</p><p>    2.yield()方法不会改变当前线程的状态，都是Runnable状态，这个方法是让当前线程有可能从Running状态–&gt;Ready状态，也有可能不礼让，当前线程只会礼让给优先级高或者相同的其他Ready状态线程。</p><p>    3、sleep()方法有声明InterruptedException异常，需要在编译期进行处理，yield()方法没有声明异常。</p><h2 id="二、线程安全与同步"><a href="#二、线程安全与同步" class="headerlink" title="二、线程安全与同步"></a>二、线程安全与同步</h2><h3 id="2-1线程安全"><a href="#2-1线程安全" class="headerlink" title="2.1线程安全"></a>2.1线程安全</h3><p>    当使用多个线程来访问同一个对象资源进行读写操作的时候，CPU的调度导致数据不一致，很容易出现线程安全问题。</p><p>    售票系统演示线程安全问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ClassName: Demo6</span><br><span class="hljs-comment"> * Package: PACKAGE_NAME</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2022/3/1 10:43</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: tancheng</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketSys</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">K78</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;   <span class="hljs-comment">// 票的数量</span><br><br>    <span class="hljs-comment">// 售票方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saleTicket</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 判断余票数</span><br>        <span class="hljs-keyword">if</span>(K78 &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 取出K78中的数据进行判断</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">50</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;抢到了第&quot;</span> + (K78--) + <span class="hljs-string">&quot;张票&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 携程网</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">XieCheng</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TicketSys ticketSys;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">XieCheng</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">XieCheng</span><span class="hljs-params">(TicketSys ticketSys, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.ticketSys = ticketSys;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">// 调用关联的系统售票</span><br>            <span class="hljs-built_in">this</span>.ticketSys.saleTicket();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 飞猪往</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyPig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TicketSys ticketSys;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FlyPig</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FlyPig</span><span class="hljs-params">(TicketSys ticketSys, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.ticketSys = ticketSys;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">// 调用关联的系统售票</span><br>            <span class="hljs-built_in">this</span>.ticketSys.saleTicket();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo6</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个售票系统</span><br>        <span class="hljs-type">TicketSys</span> <span class="hljs-variable">ts12306</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TicketSys</span>();<br><br>        <span class="hljs-comment">// 创建app</span><br>        <span class="hljs-type">XieCheng</span> <span class="hljs-variable">xc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XieCheng</span>(ts12306, <span class="hljs-string">&quot;携程&quot;</span>);<br>        <span class="hljs-type">FlyPig</span> <span class="hljs-variable">fp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyPig</span>(ts12306, <span class="hljs-string">&quot;飞猪&quot;</span>);<br><br><br>        xc.start();<br>        fp.start();<br><br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>    结构如图：</p><p><img src="https://img-blog.csdnimg.cn/a028f6c220f64630a28062c0dcbefb9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqx5b-X6KaB5b2T5p625p6E5biI55qE5bCP5p2o,size_12,color_FFFFFF,t_70,g_se,x_16" alt="img"> </p><h3 id="2-2解决线程安全问题方式（线程同步）"><a href="#2-2解决线程安全问题方式（线程同步）" class="headerlink" title="2.2解决线程安全问题方式（线程同步）"></a>2.2解决线程安全问题方式（线程同步）</h3><p>    解决线程的安全问题相对的会降低程序的运行效率，为了减少这种负面影响，建议只对需要进行修改操作的方法进行同步，单线程环境中不需要考虑线程安全，只在多线程环境中使用同步。</p><p><strong>2.2.1同步代码块</strong></p><p>    采用Java多线程的synchronized关键字来声明同步代码块，使用同步监视器锁来解决。语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(监视器锁) &#123;<br>    同步代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>    作用：被同一个监视器锁监视的代码块，一次只能让一个线程进入，进入的线程持有这个监视器锁，其他线程没有这个锁是进入不了同步代码块，其他线程就进入阻塞（blocked）状态，只有当持有同步锁的线程释放锁后，其他线程才会去争夺锁。</p><p><strong>2.2.2同步方法</strong></p><p>    与同步代码块相对应，Java多线程还提供了同步方法，使用synchronized关键字来修饰某个方法，该方法则为同步方法。</p><p>    对于synchronized修饰的实例方法（非static方法）来说，默认的同步锁对象是this，也就是调用该方法的对象，同步静态方法时默认的同步锁对象是当前字节码对象 。</p><p>    被同步监视器锁锁定的线程何时释放锁：</p><p>    ①.从同步代码块、同步方法出来时释放锁</p><p>    ②.遇到break,return</p><p>    ③. 遇到未处理的异常</p><p>    ④.遇到wait()方法释放锁，获得同步锁的线程进入waiting()</p><p><strong>2.2.3同步锁</strong></p><p>&amp;emsp;&amp;emsp;从Java5开始提供了一种更强大的线程同步方式——Lock接口。Lock中的实现类ReentrantLock(可重入锁)，使用Lock()加锁、unLock()解锁，因为需要手动控制来释放锁资源，所以需要在使用try&#x2F;catch解决异常时将unLock()方法放到finally里面释放锁资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Demo;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLock</span> &#123;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>           <span class="hljs-keyword">final</span> <span class="hljs-type">TestLock</span> <span class="hljs-variable">testLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestLock</span>();<br><br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br><br>                 <span class="hljs-meta">@Override</span><br><br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                      testLock.insert(Thread.currentThread());<br><br>                 &#125;<br><br>           &#125;.start();<br><br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br><br>                 <span class="hljs-meta">@Override</span><br><br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                      testLock.insert(Thread.currentThread());<br><br>                 &#125;<br><br>           &#125;.start();<br><br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Thread thread)</span> &#123;<br><br>           lock.lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br><br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;得到了锁&quot;</span>);<br><br>           <br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br><br>            System.out.println(thread.getName()+<span class="hljs-string">&quot;释放了锁&quot;</span>);<br><br>            lock.unlock();<br><br>        &#125;<br><br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>    其中还有个ReadWriteLock()方法，称为读写锁。可以让只需要读取功能的线程进入，将需要修改功能的线程阻塞在外面，但需要修改功能的线程只能有一个获取锁。意味着不再是只能有一个线程获取锁，更加在保证安全的同时提高程序运行的效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * Returns the lock used for reading.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for reading.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br>    Lock <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span>;<br><br> <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * Returns the lock used for writing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the lock used for writing.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br>    Lock <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java多线程-线程优先级、线程安全与同步&quot;&gt;&lt;a href=&quot;#Java多线程-线程优先级、线程安全与同步&quot; class=&quot;headerlink&quot; title=&quot;Java多线程_线程优先级、线程安全与同步&quot;&gt;&lt;/a&gt;Java多线程_线程优先级、线程安全与同步&lt;/</summary>
      
    
    
    
    
    <category term="Java" scheme="http://121.43.167.55/tags/Java/"/>
    
    <category term="多线程" scheme="http://121.43.167.55/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程安全" scheme="http://121.43.167.55/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_线程的生命周期与6种状态</title>
    <link href="http://121.43.167.55/2021/092517187.html"/>
    <id>http://121.43.167.55/2021/092517187.html</id>
    <published>2021-09-25T02:20:14.000Z</published>
    <updated>2022-07-14T12:04:49.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程-线程的生命周期与6种状态"><a href="#Java多线程-线程的生命周期与6种状态" class="headerlink" title="Java多线程_线程的生命周期与6种状态"></a>Java多线程_线程的生命周期与6种状态</h1><h2 id="一、线程的生命周期"><a href="#一、线程的生命周期" class="headerlink" title="一、线程的生命周期"></a>一、线程的生命周期</h2><p>&amp;emsp;&amp;emsp;当线程被创建并启动之后，并不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中要经过：<strong>新建(NEW)、运行(RUNNABLE)、阻塞(BLOCKED)、永久等待(WAITING)、超时等待(WIME_WAITING)、终止(TERMINATED)。</strong></p><p>&amp;emsp;&amp;emsp;当线程被启动的时候，它并不可能一直独占CPU运行，所以CPU是一直在多条线程之间来回切换运行，于是线程也是不停在运行 与 就绪之间进行切换。</p><p><img src="https://img-blog.csdnimg.cn/bb482957ef19489b9a7cb944e8b1f9c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqx5b-X6KaB5b2T5p625p6E5biI55qE5bCP5p2o,size_15,color_FFFFFF,t_70,g_se,x_16" alt="线程状态切换"> </p><p>  &amp;emsp;  &amp;emsp;Java源码中有提到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a thread which has not yet started.</span><br><span class="hljs-comment">        */</span><br>       NEW,<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="hljs-comment">        * state is executing in the Java virtual machine but it may</span><br><span class="hljs-comment">        * be waiting for other resources from the operating system</span><br><span class="hljs-comment">        * such as processor.</span><br><span class="hljs-comment">        */</span><br>       RUNNABLE,<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="hljs-comment">        * A thread in the blocked state is waiting for a monitor lock</span><br><span class="hljs-comment">        * to enter a synchronized block/method or</span><br><span class="hljs-comment">        * reenter a synchronized block/method after calling</span><br><span class="hljs-comment">        * &#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125;.</span><br><span class="hljs-comment">        */</span><br>       BLOCKED,<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a waiting thread.</span><br><span class="hljs-comment">        * A thread is in the waiting state due to calling one of the</span><br><span class="hljs-comment">        * following methods:</span><br><span class="hljs-comment">        * &lt;ul&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="hljs-comment">        * &lt;/ul&gt;</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="hljs-comment">        * perform a particular action.</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="hljs-comment">        * on an object is waiting for another thread to call</span><br><span class="hljs-comment">        * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="hljs-comment">        * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="hljs-comment">        * is waiting for a specified thread to terminate.</span><br><span class="hljs-comment">        */</span><br>       WAITING,<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a waiting thread with a specified waiting time.</span><br><span class="hljs-comment">        * A thread is in the timed waiting state due to calling one of</span><br><span class="hljs-comment">        * the following methods with a specified positive waiting time:</span><br><span class="hljs-comment">        * &lt;ul&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="hljs-comment">        *   &lt;li&gt;&#123;<span class="hljs-doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="hljs-comment">        * &lt;/ul&gt;</span><br><span class="hljs-comment">        */</span><br>       TIMED_WAITING,<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Thread state for a terminated thread.</span><br><span class="hljs-comment">        * The thread has completed execution.</span><br><span class="hljs-comment">        */</span><br>       TERMINATED;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="二、线程的主要状态"><a href="#二、线程的主要状态" class="headerlink" title="二、线程的主要状态"></a>二、线程的主要状态</h1><h3 id="1、新建状态-NEW-："><a href="#1、新建状态-NEW-：" class="headerlink" title="1、新建状态(NEW)："></a>1、新建状态(NEW)：</h3><p>&amp;emsp;&amp;emsp;实现Runnable接口和继承Thread可以得到一个线程类，使用new关键字创建了一个程序之后，改线程就处于新建状态，此时的线程和其他Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化成员变量的值。</p><p>&amp;emsp;&amp;emsp;当线程对象调用了start()方法之后，该线程处于就绪状态，Java虚拟机为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了，至于何时开始取决于CPU调度器的调度。</p><p>&amp;emsp;&amp;emsp;<strong>注意：</strong>启动线程使用方法start()，而不是run()方法！永远不要直接调用线程对象的run()方法！当调用start()方法后，系统会将该对象的run()方法作为程序执行体来处理；如果直接调用对象的run()方法，系统会将线程对象当做一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。</p><h3 id="2、运行状态-RUNNABLE"><a href="#2、运行状态-RUNNABLE" class="headerlink" title="2、运行状态(RUNNABLE):"></a>2、运行状态(RUNNABLE):</h3><p>&amp;emsp;&amp;emsp;在线程的运行状态中也可分为两个小状态：运行中状态(Running)、就绪状态(Ready)。当处于就绪状态的线程获得了CPU，将会开始执行run()方法的线程执行体，则该线程处于运行中状态。</p><p>&amp;emsp;&amp;emsp;Ready(就绪状态)： 等待调度器调度</p><p>&amp;emsp;&amp;emsp;Running（运行中状态）： 被调度器（scheduler）选中，CPU正在执行</p><p>&amp;emsp;&amp;emsp;Ready —-&gt; 调度器选中 —-&gt; Running</p><p>&amp;emsp;&amp;emsp;Running —-&gt; 调度器切换 | Thread.yeild()   方法—&gt; Ready</p><h3 id="3、永久等待状态-WAITING"><a href="#3、永久等待状态-WAITING" class="headerlink" title="3、永久等待状态(WAITING):"></a>3、永久等待状态(WAITING):</h3><p>&amp;emsp;&amp;emsp;当调用wait()方法或join()方法此时的线程将退出运行状态，进入永久等待状态，除非使用notify()方法或notifyAll()方法主动唤醒，否则永久等待。</p><p>&amp;emsp;&amp;emsp;进入永久等待状态：</p><p>&amp;emsp;&amp;emsp;Runnable –&gt;  wait()方法  | join() 方法 —-&gt; Waiting</p><p>&amp;emsp;&amp;emsp;退出永久等待状态：</p><p>&amp;emsp;&amp;emsp;Waiting -&gt;   notify()方法  | notifyAll()   —-&gt; Runnable</p><h3 id="4、超时等待状态-TIMED-WAITING-："><a href="#4、超时等待状态-TIMED-WAITING-：" class="headerlink" title="4、超时等待状态(TIMED_WAITING)："></a>4、超时等待状态(TIMED_WAITING)：</h3><p>&amp;emsp;&amp;emsp;当调用sleep(long millis)、wait(long millis)、join(long millis)这三个方法时，线程将进入超时等待状态，等待设定时间long  millis结束或使用notify()或notifyAll()对其主动唤醒退出超时等待状态，进入到运行就绪状态等待CPU调度分配资源。</p><p>&amp;emsp;&amp;emsp;进入超时等待状态：</p><p>&amp;emsp;&amp;emsp;Runnable –&gt; sleep(long millis) | wait(long millis) | join(long millis) —&gt; Timed_Waiting</p><p>&amp;emsp;&amp;emsp;超时等待状态： </p><p>&amp;emsp;&amp;emsp;Timed_Waiting –&gt; 设置时间结束 | notify() | notifyAll() –&gt; Runnable</p><h3 id="5、阻塞状态-BLOCKED-："><a href="#5、阻塞状态-BLOCKED-：" class="headerlink" title="5、阻塞状态(BLOCKED)："></a>5、阻塞状态(BLOCKED)：</h3><p>&amp;emsp;&amp;emsp;阻塞状态是被监视器锁监视的线程， 被同步锁或者IO锁阻塞 ,线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态 。为了线程的安全，使用synchronized关键字给线程上锁，使得多个线程能够有秩序的进入同步代码块获取权限。</p><p>&amp;emsp;&amp;emsp;进入阻塞状态：</p><p>&amp;emsp;&amp;emsp;Runnable —&gt; 没有获取锁  —-&gt; 阻塞  </p><p>&amp;emsp;&amp;emsp;退出阻塞状态：</p><p>&amp;emsp;&amp;emsp;阻塞  —&gt; 获取锁对象 —&gt; Runnable</p><h3 id="6、终止状态-TERMINATED"><a href="#6、终止状态-TERMINATED" class="headerlink" title="6、终止状态(TERMINATED):"></a>6、终止状态(TERMINATED):</h3><p>&amp;emsp;&amp;emsp;线程终止状态也称为线程死亡，有三种方式进入该状态：</p><p>&amp;emsp;&amp;emsp;①run()或call()方法执行完成，线程正常结束。</p><p>&amp;emsp;&amp;emsp;②线程抛出一个未捕获的Exception或Error。</p><p>&amp;emsp;&amp;emsp;③直接调用该线程的stop()方法来结束该线程—-该方法容易死锁，不建议使用。</p><p>&amp;emsp;&amp;emsp;Runnable —-&gt; 任务方法执行完毕|发生异常  —&gt; Terminated</p><p>&amp;emsp;&amp;emsp;线程对象的isAlive()方法可以返回线程的状态，当处于就绪、运行、等待、阻塞状态返回true，新建、死亡返回false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java多线程-线程的生命周期与6种状态&quot;&gt;&lt;a href=&quot;#Java多线程-线程的生命周期与6种状态&quot; class=&quot;headerlink&quot; title=&quot;Java多线程_线程的生命周期与6种状态&quot;&gt;&lt;/a&gt;Java多线程_线程的生命周期与6种状态&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://121.43.167.55/tags/Java/"/>
    
    <category term="多线程" scheme="http://121.43.167.55/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_创建线程的多种方式</title>
    <link href="http://121.43.167.55/2021/092217201.html"/>
    <id>http://121.43.167.55/2021/092217201.html</id>
    <published>2021-09-22T11:02:15.000Z</published>
    <updated>2022-07-14T12:04:32.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程-创建线程的多种方式"><a href="#Java多线程-创建线程的多种方式" class="headerlink" title="Java多线程_创建线程的多种方式"></a>Java多线程_创建线程的多种方式</h1><h2 id="一、线程与进程"><a href="#一、线程与进程" class="headerlink" title="一、线程与进程"></a>一、线程与进程</h2><p>​几乎所有的操作系统都支持进程的概念，所有运行中的任务都对应一个进程(Process)。当一个程序进入内存运行时，即变成一个进程。进程是处于运行中的程序，并且具有一定的独立功能，进程是系统进行资源调度的一个独立单位。</p><p>​一般而言，进程包含三个特征：<strong>独立性、动态性、并发性。</strong></p><p>​一个程序运行后至少会有一个进程，一个进程可以包含多个线程，但至少要有个线程。</p><p>​<strong>归纳起来就是说：操作系统可以同时执行多个任务，每个任务就是进程；进程可以同时执行多个任务，每个任务就是线程。</strong></p><h3 id="温馨提示（并发性与并行性）："><a href="#温馨提示（并发性与并行性）：" class="headerlink" title="温馨提示（并发性与并行性）："></a>温馨提示（并发性与并行性）：</h3><p>​<strong>并发性(concurrency)和并行性(parallel)是两个概念，并行是指在同一时刻，有多条指令在多个处理器上同时执行；并发是指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程被同时执行的效果。</strong></p><h2 id="二、多线程的优势"><a href="#二、多线程的优势" class="headerlink" title="二、多线程的优势"></a>二、多线程的优势</h2><p>​线程在程序中是独立的、并发的执行流，与分隔的进程相比，线程分隔程度要小很多。当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源；但创建线程则简单很多，因此使用多线程来实现并发比使用多进程实现并发要强很多。</p><p>​1、进程之间不能共享内存，但线程之间共享内存非常容易，</p><p>​2、系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价要小很多，因此使用多线程实现多任务并发要比进程效率高很多。</p><p>​3、Java语言内置了多线程功能支持，而不是单纯的作为底层操作系统的调度模式，从而简化了Java的多线程编程。</p><h2 id="三、线程的创建和启动"><a href="#三、线程的创建和启动" class="headerlink" title="三、线程的创建和启动"></a>三、线程的创建和启动</h2><p>​Java使用Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例，以下则介绍其中三种常见创建线程对象的方法。</p><h3 id="1、继承Thread类创建线程类"><a href="#1、继承Thread类创建线程类" class="headerlink" title="1、继承Thread类创建线程类"></a>1、继承Thread类创建线程类</h3><p>​创建步骤：</p><p>​①定义Thread类的子类，并重写该类的run()方法，该run()方法体就代表了线程需要完成的任务。因此吧run()方法称为线程执行体。</p><p>​②创建Thread子类的实例，即创建了线程对象。</p><p>​③调用线程对象的start()方法来启动该线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 通过继承Thread类创建线程对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yangzhihong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-02-28 20:29</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread_jc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//重写run()方法，run()方法的方法体就是线程执行体。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">//d当线程类继承Thread类时，直接使用this即可获取当前线程</span><br>            <span class="hljs-comment">//Thread对象的getName()返回当前线程的名字</span><br>            <span class="hljs-comment">//因此可以直接调用getName()方法返回当前线程的名字</span><br>            System.out.println(<span class="hljs-string">&quot;我是子线程&quot;</span> + getName() + <span class="hljs-string">&quot;&quot;</span> + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-comment">//调用Thread的currentThread()方法获取当前线程</span><br>            System.out.println(<span class="hljs-string">&quot;我是主线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;&quot;</span> + i);<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">20</span>) &#123;<br>                <span class="hljs-comment">//创建并启动第一个线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread_jc</span>().start();<br>                <span class="hljs-comment">//创建并启动第二个线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread_jc</span>().start();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Thread类提供了常用的API</p><p>Thread.currentThread() ： 静态方法用于获取当前的线程对象。</p><p>getName() : 可以获取线程对象的名称。</p><p>​主线程的名称默认是main，不能修改。</p><p>​子线程的名称默认是 Thread-0,……. </p><p>​可以修改，修改方式，可以提供有参构造方法，调用父类的有参构造方法Thread(String name)</p><p>​也可以使用setName(String name) 设置线程名称。</p><h3 id="2、实现Runnable接口创建线程"><a href="#2、实现Runnable接口创建线程" class="headerlink" title="2、实现Runnable接口创建线程"></a>2、实现Runnable接口创建线程</h3><p>​自定义一个类实现Runnable接口，这个类是一个任务类，这个任务类需要重写Runnable接口中的任务方法，这个类的对象是一个任务对象，如果这个任务对象的任务需要在子线程中执行，必须依赖线程对象。</p><p>​创建步骤：</p><p>​①定义Runnable接口的实现类，并重写该方法的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p><p>​②创建Runnable实现类的实例，并以此作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</p><p>​③调用线程线程对象的start()方法来启动线程。</p><p>​**注意：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是Thread线程负责执行其target的run()方法。4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 实现Runnable接口创建线程对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yangzhihong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-03-01 10:24</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-comment">// 自定义一个任务类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&quot;</span> + <span class="hljs-string">&quot;刷出第&quot;</span> + i + <span class="hljs-string">&quot;个小怪&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 创建任务对象</span><br>        <span class="hljs-type">MyTask</span> <span class="hljs-variable">myTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>();<br><br>        <span class="hljs-comment">// 创建线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myTask, <span class="hljs-string">&quot;子线程&quot;</span>);<br>        <span class="hljs-comment">// 开启子线程对象的任务</span><br>        thread.start();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">100</span>; j++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;----&quot;</span> + <span class="hljs-string">&quot;刷出第&quot;</span> + j + <span class="hljs-string">&quot;个大BOSS&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、使用Callable和Future创建线程"><a href="#3、使用Callable和Future创建线程" class="headerlink" title="3、使用Callable和Future创建线程"></a>3、使用Callable和Future创建线程</h3><p>​从Java5 开始，Java提供了Callable接口，该接口与Runnable接口非常相似，Callable接口提供了一个call()方法可以作为线程执行体，但call()方法比run()方法功能更强大：<strong>可以有返回值、可以声明抛出异常。</strong></p><p>​Java5 提供了一个与Callable配套的Future接口，Future有个实现类FutureTask，该类的RunnableFuture接口对Future、Runnable都进行了实现。可以作为中介来关联Runnable与Future，并通过Future的公共方法V get() 获取到Callable的返回值，于是乎Callable对象就可以作为Thread的target来创建线程了。（V get()方法中的V是表示泛型，表示Callable接口里的类型必须与call()返回值类型相同）</p><p> <img src="https://img-blog.csdnimg.cn/eb1b0288f5ee4f42b35cc351d7438997.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqx5b-X6KaB5b2T5p625p6E5biI55qE5bCP5p2o,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center"> </p><p>​创建步骤：</p><p>​①创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且该call()方法有返回值，再创建Callable实现类的实例对象。从Java8 开始可以直接使用Lambda表达式创建Callable对象。</p><p>​②使用FutureTask类包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p><p>​③使用FutureTask对象作为Thread对象的target创建并启动新线程。</p><p>​④调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@program</span>: code</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: 通过Callable与Future来创建线程对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: yangzhihong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2022-03-01 11:56</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-comment">// 实现了Callable接口的类，也是一个任务类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++) &#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableFutureThread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-comment">// 创建任务对象</span><br>        <span class="hljs-type">MyCall</span> <span class="hljs-variable">myCall</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCall</span>();<br>        <span class="hljs-comment">// 创建FutureTask对象这个对象实现了RunnableFuture接口</span><br>        <span class="hljs-comment">// RunnableFuture多继承了Runnable接口和Future接口</span><br>        <span class="hljs-comment">// 在构造FutureTask对象时，可以通过构造方法将Callable接口的</span><br>        <span class="hljs-comment">// 实现对象传入</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCall);<br>        <span class="hljs-comment">// 创建一个线程对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br>        <span class="hljs-comment">// 通过get()方法来获取Callable任务方法的返回结果</span><br>        <span class="hljs-keyword">if</span>(futureTask.isDone()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(result);<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4、这三种创建线程方式的对比"><a href="#4、这三种创建线程方式的对比" class="headerlink" title="4、这三种创建线程方式的对比"></a>4、这三种创建线程方式的对比</h3><p>​通过继承Thread类和实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值和可以声明抛出异常，因此可以将Runnable和Callable归为同一种实现接口方式。</p><p>​<strong>实现接口方式创建线程优缺点：</strong></p><p>​①线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。</p><p>​②在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源，从而可以将CPU、代码和数据分开。形成清晰的模型。较好的体现了面向对象的思想。</p><p>​③缺点，编程稍微复杂一些，如果需要访问当前线程，则必须使用Thread.currentThread()方法。</p><p>​<strong>采用继承Thread类方式创建线程优缺点：</strong></p><p>​①缺点，因为线程类已经继承了Thread类，所以不能再继承其他父类。</p><p>​②优点，编写简单，如果需要访问当前线程，则不需要使用Thread.currentThread()方法，直接this即可获得当前线程。</p><p>​<strong>因此一般推荐采用实现Runnable接口、Callable接口方式来创建多线程。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java多线程-创建线程的多种方式&quot;&gt;&lt;a href=&quot;#Java多线程-创建线程的多种方式&quot; class=&quot;headerlink&quot; title=&quot;Java多线程_创建线程的多种方式&quot;&gt;&lt;/a&gt;Java多线程_创建线程的多种方式&lt;/h1&gt;&lt;h2 id=&quot;一、线程与</summary>
      
    
    
    
    
    <category term="Java" scheme="http://121.43.167.55/tags/Java/"/>
    
    <category term="多线程" scheme="http://121.43.167.55/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
